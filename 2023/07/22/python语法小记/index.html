<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="python语法小记" />
    <meta name="hexo-theme-A4" content="v1.6.9" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>hwan | </title>

    
        
            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/reset.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/markdown.css">

            
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/fonts.css">
 
            <!--注意：首页既不是post也不是page-->
            
        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">hwan</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
            
                <li><a href="/tags/">标签</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            python语法小记
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="post-toc-text">随机数相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#random"><span class="post-toc-text">random</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83"><span class="post-toc-text">均匀分布</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="post-toc-text">文件操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%90%8Dos-path-basename"><span class="post-toc-text">从一个文件路径获取文件名os.path.basename</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%A4%8D%E5%88%B6%E7%9B%B8%E5%85%B3"><span class="post-toc-text">复制相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="post-toc-text">普通对象的复制</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%8A%A5%E9%94%99%E7%9B%B8%E5%85%B3"><span class="post-toc-text">报错相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%A7%E7%94%9F%E9%94%99%E8%AF%AF"><span class="post-toc-text">产生错误</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeError"><span class="post-toc-text">TypeError</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%9D%82"><span class="post-toc-text">杂</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MethodType"><span class="post-toc-text">MethodType()</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#List%E7%9B%B8%E5%85%B3"><span class="post-toc-text">List相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="post-toc-text">*运算符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%B9%E5%88%97%E8%A1%A8%E4%B9%98%E6%B3%95"><span class="post-toc-text">对列表乘法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SET%E7%9B%B8%E5%85%B3"><span class="post-toc-text">SET相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="post-toc-text">定义</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#dict%E7%9B%B8%E5%85%B3"><span class="post-toc-text">dict相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="post-toc-text">get方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#pop%E6%96%B9%E6%B3%95"><span class="post-toc-text">pop方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#setdefault"><span class="post-toc-text">setdefault()</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#class%E7%9B%B8%E5%85%B3"><span class="post-toc-text">class相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="post-toc-text">静态方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="post-toc-text">类方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="post-toc-text">类变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E7%B1%BB"><span class="post-toc-text">判断一个对象是否类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E5%88%AB%E7%9A%84%E6%98%AF%E5%90%A6%E5%AF%B9%E5%BA%94%E5%B1%9E%E6%80%A7"><span class="post-toc-text">判断别的是否对应属性</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#property"><span class="post-toc-text">@property</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link"><span class="post-toc-text"></span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%9C-repr-%E2%80%9C"><span class="post-toc-text">“_repr_“</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%9C-getattr-%E2%80%9C"><span class="post-toc-text">“_getattr_“</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E2%80%9C-call-%E2%80%9C"><span class="post-toc-text">“_call_“</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E6%9D%82-1"><span class="post-toc-text">杂</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96%E5%90%8E%E7%AB%AF-FileClient"><span class="post-toc-text">文件获取后端 FileClient</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#np-generic%E4%B8%BE%E4%BE%8B"><span class="post-toc-text">np.generic举例</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA-Type-Hints-%E8%AF%AD%E6%B3%95"><span class="post-toc-text">类型提示(Type Hints)语法</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-property"><span class="post-toc-text">python @property</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-abstractmethod"><span class="post-toc-text">python @abstractmethod</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-classmethod"><span class="post-toc-text">python @classmethod</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-staticmethod"><span class="post-toc-text">python @staticmethod</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-call"><span class="post-toc-text">python call</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AF%B9%E5%AD%97%E5%85%B8%E8%A7%A3%E5%8C%85"><span class="post-toc-text">python **运算符对字典解包</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-%E5%AD%97%E5%85%B8%E5%BD%A2%E5%8F%82"><span class="post-toc-text">python 字典形参</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="post-toc-text">python 占位符</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#python-%E6%96%87%E4%BB%B6"><span class="post-toc-text">python 文件</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="post-toc-text">修饰器</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#pytorch%E7%9B%B8%E5%85%B3"><span class="post-toc-text">pytorch相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9B%B8%E5%85%B3"><span class="post-toc-text">概率论相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#torch-distributions-distribution-Distribution"><span class="post-toc-text">torch.distributions.distribution.Distribution</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#-1"><span class="post-toc-text"></span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#module%E7%9B%B8%E5%85%B3"><span class="post-toc-text">module相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-text">参数初始化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#nn-init-xavier-uniform"><span class="post-toc-text">nn.init.xavier_uniform_</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nn-Identity"><span class="post-toc-text">nn.Identity()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#nn-Sequential"><span class="post-toc-text">nn.Sequential</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%8A%B6%E6%80%81"><span class="post-toc-text">模型状态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">加载预训练的模型</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="post-toc-text">数学运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3"><span class="post-toc-text">统计相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#torch-norm"><span class="post-toc-text">torch.norm</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="post-toc-text">矩阵运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#torch-matmul"><span class="post-toc-text">torch.matmul</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#torch-mul"><span class="post-toc-text">torch.mul()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#torch-dot"><span class="post-toc-text">torch.dot()</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#dataset%E7%9B%B8%E5%85%B3"><span class="post-toc-text">dataset相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Sampler"><span class="post-toc-text">Sampler</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RandomSampler"><span class="post-toc-text">RandomSampler</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#set-epoch"><span class="post-toc-text">set_epoch</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="post-toc-text">优化器相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#param-groups"><span class="post-toc-text">param_groups</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A2%AF%E5%BA%A6%E7%9B%B8%E5%85%B3"><span class="post-toc-text">梯度相关</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A2%AF%E5%BA%A6%E8%A3%81%E5%89%AA%E4%BB%A3%E7%A0%81"><span class="post-toc-text">梯度裁剪代码</span></a></li></ol></li></ol></li></ol>
        
        <h1 id="随机数相关"><a href="#随机数相关" class="headerlink" title="随机数相关"></a>随机数相关</h1><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><pre><code>import random
_rand = random.uniform(0, 1)
</code></pre>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h6 id="从一个文件路径获取文件名os-path-basename"><a href="#从一个文件路径获取文件名os-path-basename" class="headerlink" title="从一个文件路径获取文件名os.path.basename"></a>从一个文件路径获取文件名os.path.basename</h6><pre><code>import os

path = &#39;/path/to/config.cfg&#39;
filename = os.path.basename(path)
print(filename)  # 输出：config.cfg
</code></pre>
<h1 id="复制相关"><a href="#复制相关" class="headerlink" title="复制相关"></a>复制相关</h1><h2 id="普通对象的复制"><a href="#普通对象的复制" class="headerlink" title="普通对象的复制"></a>普通对象的复制</h2><pre><code>a=list()
b=a.copy()
</code></pre>
<h1 id="报错相关"><a href="#报错相关" class="headerlink" title="报错相关"></a>报错相关</h1><h2 id="产生错误"><a href="#产生错误" class="headerlink" title="产生错误"></a>产生错误</h2><h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h3><pre><code> raise TypeError(&#39;module must be a class, but got &#123;&#125;&#39;.format(type(module_class)))
</code></pre>
<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="MethodType"><a href="#MethodType" class="headerlink" title="MethodType()"></a>MethodType()</h2><pre><code>from types import MethodType

class MyClass:
    def __init__(self, x):
        self.x = x

def my_method(self):
    print(self.x)

obj = MyClass(123)
obj.my_method = MethodType(my_method, obj)
obj.my_method()  # 输出：123
</code></pre>
<h1 id="List相关"><a href="#List相关" class="headerlink" title="List相关"></a>List相关</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="*运算符"></a>*运算符</h2><p>使用 <code>*</code> 对一个列表进行操作会将列表中的元素拆分开，作为函数参数或列表字面量的元素。这个操作被称为“拆包”（unpacking）。</p>
<pre><code>my_list = [1, 2, 3]
print(*my_list)  # 输出 1 2 3
list1 = [1, 2, 3]
list2 = [4, 5, 6]
new_list = [*list1, *list2]

print(new_list)  # 输出 [1, 2, 3, 4, 5, 6]
</code></pre>
<h2 id="对列表乘法"><a href="#对列表乘法" class="headerlink" title="对列表乘法"></a>对列表乘法</h2><p>[[0, 1], [1, 0]] * 3 &#x3D; [[0, 1], [1, 0], [0, 1], [1, 0], [0, 1], [1, 0]]</p>
<h1 id="SET相关"><a href="#SET相关" class="headerlink" title="SET相关"></a>SET相关</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个 set 对象是一组不重复的元素，其中每个元素都是唯一的。</p>
<pre><code># 创建一个 set 对象
my_set = &#123;1, 2, 3, 4, 5&#125;

# 创建另一个 set 对象
my_set_2 = set([3, 4, 5, 6, 7])
</code></pre>
<pre><code># 获取 set 对象中元素的数量
print(len(my_set))  # 输出 5

# 检查元素是否存在于 set 对象中
print(3 in my_set)  # 输出 True
print(6 in my_set)  # 输出 False

# 将元素添加到 set 对象中
my_set.add(6)
print(my_set)  # 输出 &#123;1, 2, 3, 4, 5, 6&#125;

# 从 set 对象中删除元素
my_set.remove(6)
print(my_set)  # 输出 &#123;1, 2, 3, 4, 5&#125;
</code></pre>
<h1 id="dict相关"><a href="#dict相关" class="headerlink" title="dict相关"></a>dict相关</h1><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p> <code>get</code> 方法用于获取字典中指定键的值。</p>
<pre><code>my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;

# 获取键为 &#39;a&#39; 的值
value1 = my_dict.get(&#39;a&#39;)
print(value1)  # 输出：1

# 获取键为 &#39;d&#39; 的值，返回默认值 None
value2 = my_dict.get(&#39;d&#39;)
print(value2)  # 输出：None

# 获取键为 &#39;d&#39; 的值，返回默认值 0
value3 = my_dict.get(&#39;d&#39;, 0)
print(value3)  # 输出：0
</code></pre>
<h2 id="pop方法"><a href="#pop方法" class="headerlink" title="pop方法"></a>pop方法</h2><p>用于删除并返回指定键的值。</p>
<pre><code>my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;

# 删除键为 &#39;a&#39; 的项，并返回其值
value1 = my_dict.pop(&#39;a&#39;)
print(value1)  # 输出：1
print(my_dict)  # 输出：&#123;&#39;b&#39;: 2, &#39;c&#39;: 3&#125;
</code></pre>
<h2 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault()"></a>setdefault()</h2><p>假设有一个字典<code>my_dict</code>，其初始值为<code>&#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;</code>，我们可以使用<code>setdefault()</code>方法获取某个键值对应的值，如果该键不存在，则新增该键，并将其值设置为默认值：</p>
<pre><code># 定义一个字典
my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;

# 获取键值为&#39;c&#39;的值，因为该键不存在，所以默认值为3，并将该键值对加入字典中
value = my_dict.setdefault(&#39;c&#39;, 3)

# 输出字典的值
print(my_dict)  # &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;
print(value)    # 3
</code></pre>
<h1 id="class相关"><a href="#class相关" class="headerlink" title="class相关"></a>class相关</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类里面定义，不需要以self做为输入变量的</p>
<pre><code>class MyClass:
    @staticmethod
    def my_static_method():
        print(&quot;This is a static method.&quot;)

# 用类名调用静态方法
MyClass.my_static_method()

# 用实列调用静态方法
a=MyClass()
a.my_static_method()
</code></pre>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><pre><code>class MyClass:
    
    def my_static_method(self):
        print(&quot;This is a static method.&quot;)

    self.my_static_method() #在类里面通过Self.什么便可以调用

# 用实列调用静态方法
a=MyClass()
a.my_static_method()
</code></pre>
<h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>一个类中在 <code>__init__</code> 方法之外定义的变量是类变量（class variable）。类变量是指在类定义中定义的变量，可以被该类的所有实例共享，也可以被该类的任何方法调用和修改。</p>
<pre><code>
class MyClass:
    x = 10

    def __init__(self, y):
        self.y = y

    def add(self):
        return MyClass.x + self.y
</code></pre>
<p><code>MyClass.x</code> 来访问类变量。</p>
<pre><code>class MyClass:
    x = 10
    def __init__(self, x):
        self.x = x

# 创建一个类的实例，并传递参数
obj = MyClass(20)

# 输出实例变量 x 和类变量 x 的值
print(obj.x)   # 输出 20
print(MyClass.x)  # 输出 10
</code></pre>
<h2 id="判断一个对象是否类"><a href="#判断一个对象是否类" class="headerlink" title="判断一个对象是否类"></a>判断一个对象是否类</h2><p>import inspect</p>
<p>inspect.isclass(输入)</p>
<h6 id="判断别的是否对应属性"><a href="#判断别的是否对应属性" class="headerlink" title="判断别的是否对应属性"></a>判断别的是否对应属性</h6><pre><code>isinstance(cfg, dict)
</code></pre>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><pre><code>class MyClass:
    def __init__(self, x):
        self._x = x

    @property
    def x(self):
        return self._x
</code></pre>
<p><code>@property</code> 装饰器将方法 <code>x</code> 转换为只读属性。该属性的值可以通过访问 <code>my_object.x</code> 来获取，而不需要使用 <code>my_object.x()</code> 的方法调用语法。</p>
<p>使用 <code>@property</code> 装饰器装饰的方法必须满足以下条件：</p>
<ol>
<li><p>方法名与属性名相同。例如，在上面的示例中，方法名为 <code>x</code>，属性名也为 <code>x</code>。</p>
</li>
<li><p>方法没有参数。例如，在上面的示例中，方法 <code>x</code> 没有参数。</p>
</li>
<li><p>方法必须有返回值。例如，在上面的示例中，方法 <code>x</code> 返回属性 <code>_x</code> 的值。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></li>
</ol>
<h2 id="“-repr-“"><a href="#“-repr-“" class="headerlink" title="“_repr_“"></a>“_<em>repr</em>_“</h2><pre><code>class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f&quot;MyClass(x=&#123;self.x&#125;, y=&#123;self.y&#125;)&quot;

obj = MyClass(1, 2)
print(obj)  # 输出：MyClass(x=1, y=2)
</code></pre>
<h2 id="“-getattr-“"><a href="#“-getattr-“" class="headerlink" title="“_getattr_“"></a>“_<em>getattr</em>_“</h2><p>它用于获取对象的属性值。getattr()函数有三个参数：对象、属性名称和默认值。</p>
<p>当对象存在指定属性时，getattr()函数将返回该属性的值。如果对象不存在指定属性，则返回默认值（如果指定了的话）。</p>
<pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
</code></pre>
<p>我们可以创建一个Person对象p，然后使用getattr()函数获取它的属性值：</p>
<pre><code>p = Person(&#39;Alice&#39;, 25)
name = getattr(p, &#39;name&#39;)
age = getattr(p, &#39;age&#39;)
</code></pre>
<p>具体使用的列子：</p>
<pre><code class="python">from addict import Dict
class ConfigDict(Dict):
    def __getattr__(self, name):
        try:
            value = super(ConfigDict, self).__getattr__(name)
        except KeyError:
            ex = AttributeError(f&quot;&#39;&#123;self.__class__.__name__&#125;&#39; object has no &quot;
                                f&quot;attribute &#39;&#123;name&#125;&#39;&quot;)
        except Exception as e:
            ex = e
        else:
            return value
        raise ex
</code></pre>
<h2 id="“-call-“"><a href="#“-call-“" class="headerlink" title="“_call_“"></a>“_<em>call</em>_“</h2><p>让一个对象像函数一样被调用，</p>
<p>我们可以使用 <code>()</code> 运算符来调用一个函数。当我们调用一个对象时，Python 会首先检查这个对象是否实现了 <code>__call__</code> 方法。如果实现了，Python 就会调用这个方法来执行对象的操作。</p>
<p>注意，首先要先实例化，然后再用实例化后的对象();</p>
<pre><code>class MyObject:
    def __call__(self, arg):
        print(&quot;Calling MyObject with argument:&quot;, arg)
</code></pre>
<pre><code># 创建一个 MyObject 对象
obj = MyObject()

# 调用 obj 对象，将字符串作为参数传递
obj(&quot;Hello, world!&quot;)
</code></pre>
<h1 id="杂-1"><a href="#杂-1" class="headerlink" title="杂"></a>杂</h1><p>在Python中，如果要定义一个抽象类，需要使用abc模块。下面是一个使用@abstractmethod装饰器定义抽象方法的例子：</p>
<pre><code>from abc import ABC, abstractmethod

class MyAbstractClass(ABC):
    @abstractmethod
    def my_abstract_method(self):
        pass
</code></pre>
<p>自己写装饰器</p>
<p>先定义一个装饰器</p>
<pre><code>def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(&#39;Before the function is called.&#39;)
        result = func(*args, **kwargs)
        print(&#39;After the function is called.&#39;)
        return result
    return wrapper
</code></pre>
<p>上面的代码定义了一个名为my_decorator的装饰器，它接受一个函数作为参数，并返回一个新的函数wrapper。wrapper函数在调用原函数之前和之后会打印一些信息，以增强原函数的功能。使用装饰器时，只需要在原函数前面加上@my_decorator即可将装饰器应用到原函数中，例如：</p>
<pre><code>@my_decorator
def my_function():
    print(&#39;This is my function.&#39;)
</code></pre>
<p>在上面的例子中，my_function函数被@my_decorator装饰器装饰，当调用my_function函数时，会先打印’Before the function is called.’，然后执行原函数的代码，最后打印’After the function is called.’。</p>
<h6 id="文件获取后端-FileClient"><a href="#文件获取后端-FileClient" class="headerlink" title="文件获取后端 FileClient"></a>文件获取后端 FileClient</h6><p>主要用于训练过程中数据的读取，通过用户选择或者自定义不同的 FileClient 后端，可以轻松实现文件缓存、文件加速读取等功能</p>
<h6 id="np-generic举例"><a href="#np-generic举例" class="headerlink" title="np.generic举例"></a>np.generic举例</h6><pre><code>import numpy as np

# 创建一个numpy数组
my_array = np.array([1, 2, 3], dtype=np.int32)

# 将numpy数组转换为Python列表
my_list = my_array.tolist()

# 打印Python列表
print(my_list)

# 将numpy的generic类型转换为Python内置类型
my_int32 = np.int32(3)
my_int = my_int32.item()

# 打印转换后的Python内置类型
print(type(my_int))  # &lt;class &#39;int&#39;&gt;
</code></pre>
<h6 id="类型提示-Type-Hints-语法"><a href="#类型提示-Type-Hints-语法" class="headerlink" title="类型提示(Type Hints)语法"></a>类型提示(Type Hints)语法</h6><pre><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union
</code></pre>
<p><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union</code>这行代码是Python中的类型提示(Type Hints)语法，它用于声明函数和变量的参数类型和返回值类型。这样做可以提高代码的可读性、可维护性和可靠性。</p>
<p>具体来说，这行代码中声明了以下类型：</p>
<ul>
<li><code>Any</code>: 表示任意类型，相当于不做类型限制。</li>
<li><code>Callable</code>: 表示一个可调用对象，例如函数或方法。</li>
<li><code>Dict</code>: 表示一个字典类型，其中键和值的类型可以是任意类型。</li>
<li><code>List</code>: 表示一个列表类型，其中元素的类型可以是任意类型。</li>
<li><code>Optional</code>: 表示一个可选类型，即参数可以是指定类型或<code>None</code>。</li>
<li><code>TextIO</code>: 表示一个文本流对象，例如文件、标准输入输出等。</li>
<li><code>Union</code>: 表示多个类型中的任意一种类型。</li>
</ul>
<pre><code>def my_function(my_list: List[int], my_dict: Optional[Dict[str, Any]]) -&gt; Union[int, float]:
    # 函数体
    pass
</code></pre>
<p>FileLikeObject &#x3D; Union[TextIO, StringIO, BytesIO]这行代码是Python中的类型提示(Type Hints)语法，用于定义一个新的类型FileLikeObject。在这个代码中，FileLikeObject是一个由Union类型组成的联合类型，它表示可以是TextIO、StringIO或BytesIO类型中的任何一种。</p>
<p>TextIO、StringIO和BytesIO是Python内置的文件流对象，用于处理文本和二进制数据。TextIO可以用于读写文本文件，StringIO可以在内存中读写字符串，BytesIO可以在内存中读写二进制数据。这些对象都实现了文件流操作接口，并且可以像文件一样读写数据。</p>
<pre><code>FileLikeObject = Union[TextIO, StringIO, BytesIO]
</code></pre>
<p>f是一个变量名，FileLikeObject是该变量的类型。</p>
<pre><code>f: FileLikeObject
</code></pre>
<h6 id="python-property"><a href="#python-property" class="headerlink" title="python @property"></a>python @property</h6><p>用于将一个方法转换为属性调用。在Python中，属性通常被视为类的一部分，它们提供了一种简单的方式来访问和修改对象的状态。</p>
<p>通过将一个方法标记为@property，我们可以将它转换为一个只读属性。这意味着，当我们访问该属性时，实际上是调用了该方法，并返回了它的返回值。</p>
<pre><code>class MyClass:
    @property
    def name(self):
        return self.__class__.__name__

obj = MyClass()
print(obj.name)  # 输出 &quot;MyClass&quot;
</code></pre>
<h6 id="python-abstractmethod"><a href="#python-abstractmethod" class="headerlink" title="python @abstractmethod"></a>python @abstractmethod</h6><p>用于将一个方法定义为抽象方法。抽象方法是一种特殊的方法，它没有具体的实现，只是定义了一个接口，需要在子类中进行实现。</p>
<h6 id="python-classmethod"><a href="#python-classmethod" class="headerlink" title="python @classmethod"></a>python @classmethod</h6><p>通过将一个方法标记为@classmethod，我们可以将它转换为类方法。在类方法中，第一个参数通常被命名为cls，它指代当前类对象本身。使用cls参数，我们可以在类方法中访问类的属性和方法，从而实现对类的操作。</p>
<pre><code>class MyClass:
    @classmethod
    def add(cls, x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-staticmethod"><a href="#python-staticmethod" class="headerlink" title="python @staticmethod"></a>python @staticmethod</h6><p>静态方法是一种特殊的方法，它不需要访问实例的状态或类的状态，而是仅依赖于传入的参数。通过将一个方法标记为@staticmethod，我们可以将它转换为静态方法。在静态方法中，不需要使用self或cls等参数来引用实例或类对象，而是可以直接使用传入的参数进行计算。</p>
<pre><code>class MyClass:
    @staticmethod
    def add(x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-call"><a href="#python-call" class="headerlink" title="python call"></a>python <strong>call</strong></h6><pre><code>class MyClass:
    def __call__(self, x):
        return x + 1

obj = MyClass()
result = obj(10)
print(result)  # 输出 11
</code></pre>
<h6 id="python-运算符对字典解包"><a href="#python-运算符对字典解包" class="headerlink" title="python **运算符对字典解包"></a>python **运算符对字典解包</h6><pre><code>def my_func(a, b):
    print(a, b)

env = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;
my_func(**env)  # 输出 1 2
</code></pre>
<h6 id="python-字典形参"><a href="#python-字典形参" class="headerlink" title="python 字典形参"></a>python 字典形参</h6><pre><code>def my_func(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_func(a=1, b=2, c=3)  # 输出 a 1 b 2 c 3
</code></pre>
<h6 id="python-占位符"><a href="#python-占位符" class="headerlink" title="python 占位符"></a>python 占位符</h6><pre><code>item1 = &#39;&#123;&#125;&#39;
item2 = &#39;&#123;&#125;/path/to/dir&#39;
item3 = &#39;abc_&#123;&#125;.txt&#39;

item1 = &#39;&#123;&#125;&#39;.format(&#39;filename&#39;)
item2 = &#39;&#123;&#125;/path/to/dir&#39;.format(&#39;C:/&#39;)
item3 = &#39;abc_&#123;&#125;.txt&#39;.format(&#39;file&#39;)
</code></pre>
<h6 id="python-文件"><a href="#python-文件" class="headerlink" title="python 文件"></a>python 文件</h6><p>..&#x2F;a2与..a2一样吗</p>
<p>不完全相同。..&#x2F;a2 和 ..a2 都表示上一级目录下的 a2 目录，但是它们所表示的路径格式不同。</p>
<p>..&#x2F;a2 使用了标准的相对路径格式，其中 .. 表示上一级目录，&#x2F; 表示目录的分隔符，因此 ..&#x2F;a2 表示上一级目录下的 a2 目录。这种表示方法是在文件系统中广泛使用的相对路径格式。</p>
<p>..a2 则是一种非标准的相对路径格式，使用了点号 . 和 .. 表示路径的相对位置。在 Python 等编程语言中，通常使用点号 . 表示当前目录，使用 .. 表示上一级目录，将它们与目录名拼接起来表示相对路径。因此，..a2 可以理解为上一级目录下的 a2 目录，但是这种表示方法在文件系统中并不通用。</p>
<p>总之，..&#x2F;a2 是标准的相对路径格式，而 ..a2 则是一种非标准的相对路径格式，使用时需要注意。</p>
<h6 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h6><p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p>
<pre><code>def a_new_decorator(a_func):
 
    def wrapTheFunction():
        print(&quot;I am doing some boring work before executing a_func()&quot;)
 
        a_func()
 
        print(&quot;I am doing some boring work after executing a_func()&quot;)
 
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;
    print(&quot;I am the function which needs some decoration to &quot;
          &quot;remove my foul smell&quot;)
          
a_function_requiring_decoration()
#outputs: I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()
</code></pre>
<h1 id="pytorch相关"><a href="#pytorch相关" class="headerlink" title="pytorch相关"></a>pytorch相关</h1><h2 id="概率论相关"><a href="#概率论相关" class="headerlink" title="概率论相关"></a>概率论相关</h2><h3 id="torch-distributions-distribution-Distribution"><a href="#torch-distributions-distribution-Distribution" class="headerlink" title="torch.distributions.distribution.Distribution"></a>torch.distributions.distribution.Distribution</h3><pre><code>torch.distributions.distribution.Distribution(batch_shape=torch.Size([]), event_shape=torch.Size([]), validate_args=None)
</code></pre>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h2 id="module相关"><a href="#module相关" class="headerlink" title="module相关"></a>module相关</h2><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><h4 id="nn-init-xavier-uniform"><a href="#nn-init-xavier-uniform" class="headerlink" title="nn.init.xavier_uniform_"></a>nn.init.xavier_uniform_</h4><p>将权重参数初始化为均匀分布的随机值</p>
<pre><code>nn.init.xavier_uniform_(self.linear.weight, gain=0.01)
</code></pre>
<p>官网的列子</p>
<pre><code>w = torch.empty(3, 5)
nn.init.xavier_uniform_(w, gain=nn.init.calculate_gain(&#39;relu&#39;))
</code></pre>
<p>gain为一个激活函数的增益值</p>
<h3 id="nn-Identity"><a href="#nn-Identity" class="headerlink" title="nn.Identity()"></a>nn.Identity()</h3><p>我们希望直接传递输入，不进行任何变换，这时候就可以使用 <code>nn.Identity()</code> 层。</p>
<h3 id="nn-Sequential"><a href="#nn-Sequential" class="headerlink" title="nn.Sequential"></a>nn.Sequential</h3><pre><code>fc_layers = []
fc_layers.append(nn.linear(1,2))
fc_layers.append(nn.linear(2,2))
nn.Sequential(*fc_layers)
</code></pre>
<h2 id="模型状态"><a href="#模型状态" class="headerlink" title="模型状态"></a>模型状态</h2><pre><code>model_state=model.state_dict()
</code></pre>
<h3 id="加载预训练的模型"><a href="#加载预训练的模型" class="headerlink" title="加载预训练的模型"></a>加载预训练的模型</h3><pre><code># Imagenet pretrain model
import torchvision.models as tm  # noqa: F401,F403
assert cfg[&#39;NUM_LAYERS&#39;] in [18, 34, 50, 101, 152]
x = eval(f&quot;tm.resnet&#123;cfg[&#39;NUM_LAYERS&#39;]&#125;(pretrained=True)&quot;)

# self.preact是自己的resnet
self.preact = ResNet(f&quot;resnet&#123;cfg[&#39;NUM_LAYERS&#39;]&#125;&quot;)

model_state = self.preact.state_dict()
state = &#123;k: v for k, v in x.state_dict().items() if k in self.preact.state_dict() and v.size() == self.preact.state_dict()[k].size()&#125;
model_state.update(state)
self.preact.load_state_dict(model_state)
</code></pre>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="统计相关"><a href="#统计相关" class="headerlink" title="统计相关"></a>统计相关</h3><h4 id="torch-norm"><a href="#torch-norm" class="headerlink" title="torch.norm"></a>torch.norm</h4><p>torch.norm(<em>input</em>, <em>p&#x3D;’fro’</em>, <em>dim&#x3D;None</em>, <em>keepdim&#x3D;False</em>, <em>out&#x3D;None</em>, <em>dtype&#x3D;None</em>)</p>
<p>求P范数</p>
<p>，fro是矩阵的F范数就是向量化再求二范数</p>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="torch-matmul"><a href="#torch-matmul" class="headerlink" title="torch.matmul"></a>torch.matmul</h4><p>矩阵乘法函数，用于计算两个张量的矩阵乘积。</p>
<pre><code># vector x vector                       #  两向量点积
tensor1 = torch.randn(3)
tensor2 = torch.randn(3)
torch.matmul(tensor1, tensor2).size()

# matrix x vector
tensor1 = torch.randn(3, 4)
tensor2 = torch.randn(4)
torch.matmul(tensor1, tensor2).size()	# torch.Size([3])
# batched matrix x broadcasted vector
tensor1 = torch.randn(10, 3, 4)
tensor2 = torch.randn(4)
torch.matmul(tensor1, tensor2).size()	# torch.Size([10, 3])
# batched matrix x batched matrix
tensor1 = torch.randn(10, 3, 4)
tensor2 = torch.randn(10, 4, 5)
torch.matmul(tensor1, tensor2).size()	# torch.Size([10, 3, 5])
# batched matrix x broadcasted matrix
tensor1 = torch.randn(10, 3, 4)
tensor2 = torch.randn(4, 5)
torch.matmul(tensor1, tensor2).size()
</code></pre>
<h4 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul()"></a>torch.mul()</h4><p>逐元素乘法</p>
<pre><code>import torch

a = torch.tensor([1, 2, 3])
b = torch.tensor([4, 5, 6])

c = torch.mul(a, b)
print(c)  # tensor([ 4, 10, 18])
</code></pre>
<h4 id="torch-dot"><a href="#torch-dot" class="headerlink" title="torch.dot()"></a>torch.dot()</h4><p>点积</p>
<pre><code>import torch

u = torch.tensor([1, 2, 3])
v = torch.tensor([4, 5, 6])

d = torch.dot(u, v)
print(d)  # tensor(32)
</code></pre>
<h2 id="dataset相关"><a href="#dataset相关" class="headerlink" title="dataset相关"></a>dataset相关</h2><h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p><code>Sampler</code> 类是一个用于定义数据集中样本的顺序或采样策略的抽象基类</p>
<p><code>Sampler</code> 对数据集中的样本进行采样，以控制每个 batch 中的样本数量和顺序。</p>
<h4 id="RandomSampler"><a href="#RandomSampler" class="headerlink" title="RandomSampler"></a>RandomSampler</h4><h5 id="set-epoch"><a href="#set-epoch" class="headerlink" title="set_epoch"></a>set_epoch</h5><p>在每个 epoch 开始时，我们可以使用 <code>set_epoch</code> 方法来设置采样器的当前 epoch 值，以确保每个 epoch 中的样本顺序和数量都是不同的。</p>
<p>列如：</p>
<pre><code>from torch.utils.data import RandomSampler

# 创建一个 RandomSampler 采样器
sampler = RandomSampler(dataset)

# 训练神经网络
for i in range(num_epochs):
    # 设置采样器的当前 epoch 值
    sampler.set_epoch(i)
    
    # 创建 DataLoader，并使用 RandomSampler 采样器
    dataloader = DataLoader(dataset, batch_size=batch_size, sampler=sampler)
    
    # 在数据集上迭代
    for batch in dataloader:
        # 处理 batch 数据
        ...
</code></pre>
<p>在这个示例中，我们在训练神经网络的每个 epoch 开始时，使用 <code>set_epoch</code> 方法将采样器的当前 epoch 值设置为当前 epoch 的索引 <code>i</code>。然后，我们创建一个 DataLoader 对象，并将 <code>RandomSampler</code> 采样器应用于该数据集。在数据集上迭代时，<code>RandomSampler</code> 采样器将根据当前 epoch 值对数据集中的样本进行随机采样，以确保每个 batch 中的样本顺序和数量都是不同的。</p>
<h2 id="优化器相关"><a href="#优化器相关" class="headerlink" title="优化器相关"></a>优化器相关</h2><p><code>Optimizer</code> 是一个用于优化神经网络模型参数的类。</p>
<h3 id="param-groups"><a href="#param-groups" class="headerlink" title="param_groups"></a>param_groups</h3><p><code>param_groups</code> 是 <code>Optimizer</code> 类的一个属性，它返回一个包含优化器参数组的列表。每个参数组都是一个字典，</p>
<p><code>optimizer.param_groups[0]</code>：长度为7的字典，包括[‘<strong>params</strong>’, ‘<strong>lr</strong>’, ‘<strong>betas</strong>’, ‘<strong>eps</strong>’, ‘<strong>weight_decay</strong>’, ‘<strong>amsgrad</strong>’, ‘<strong>maximize</strong>’]这7个参数；</p>
<p>例如</p>
<pre><code>&gt;&gt;&gt; optimizer.param_groups[0].keys()
&gt;&gt;&gt; dict_keys([&#39;params&#39;, &#39;lr&#39;, &#39;betas&#39;, &#39;eps&#39;, &#39;weight_decay&#39;, &#39;amsgrad&#39;, &#39;maximize&#39;])
</code></pre>
<p><code>params</code> 是一个list[…]，里面存放参数</p>
<pre><code>&gt;&gt;&gt; len(optimizer.param_groups[0][&#39;params&#39;])
&gt;&gt;&gt; 48
&gt;&gt;&gt; optimizer.param_groups[0][&#39;params&#39;][0]
&gt;&gt;&gt; 
Parameter containing:
tensor([[ 0.0212, -0.1151,  0.0499,  ..., -0.0807, -0.0572,  0.1166],
        [-0.0356, -0.0397, -0.0980,  ...,  0.0690, -0.1066, -0.0583],
        [ 0.0238,  0.0316, -0.0636,  ...,  0.0754, -0.0891,  0.0258],
        ...,
        [ 0.0603, -0.0173,  0.0627,  ...,  0.0152, -0.0215, -0.0730],
        [-0.1183, -0.0636,  0.0381,  ...,  0.0745, -0.0427, -0.0713],
</code></pre>
<p><code>lr</code> 是学习率</p>
<pre><code>&gt;&gt;&gt; optimizer.param_groups[0][&#39;lr&#39;]
&gt;&gt;&gt; 0.0005
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xxmy7/article/details/125967239">https://blog.csdn.net/xxmy7/article/details/125967239</a> 看这个链接</p>
<h2 id="梯度相关"><a href="#梯度相关" class="headerlink" title="梯度相关"></a>梯度相关</h2><h3 id="梯度裁剪代码"><a href="#梯度裁剪代码" class="headerlink" title="梯度裁剪代码"></a>梯度裁剪代码</h3><pre><code>def clip_gradient(optimizer, max_norm, norm_type):
    &quot;&quot;&quot;
    Clips gradients computed during backpropagation to avoid explosion of gradients.

    :param optimizer: optimizer with the gradients to be clipped
    :param grad_clip: clip value
    &quot;&quot;&quot;
    for group in optimizer.param_groups:
        for param in group[&quot;params&quot;]:
            clip_grad.clip_grad_norm_(param, max_norm, norm_type)
</code></pre>
<pre><code># 在RLE中设置的为
grad_clip = &#123;&#39;MAX_NORM&#39;: 35, &#39;NORM_TYPE&#39;: 2&#125;

optimizer.zero_grad()
loss.backward()
if grad_clip:
    clip_gradient(optimizer, grad_clip.MAX_NORM, grad_clip.NORM_TYPE)
    
optimizer.step()
</code></pre>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-07-22</span>
            
            
             
        
        </i>
    </div>
    
        

     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
             

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>花有重开日，人无再少年！</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
        
<link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/a11y-dark.min.css">

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlight.min.js"></script>

        
<script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/highlightjs-line-numbers.js"></script>

    


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>