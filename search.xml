<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客记录</title>
    <url>/2023/06/26/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190</a> 龙哥的链接</li>
<li>hexo主题相关的<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></li>
<li>我博客使用的主题<a href="https://github.com/HiNinoJay/hexo-theme-A4">https://github.com/HiNinoJay/hexo-theme-A4</a></li>
<li>typora添加图片<a href="https://blog.51cto.com/u_15854687/5811585">https://blog.51cto.com/u_15854687/5811585</a><br><a href="https://blog.csdn.net/Qxiaofei_/article/details/124629908">https://blog.csdn.net/Qxiaofei_/article/details/124629908</a></li>
<li>typora安装url</li>
</ol>
]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>ovd</title>
    <url>/2023/06/27/ovd/</url>
    <content><![CDATA[<h6 id="COCO数据集"><a href="#COCO数据集" class="headerlink" title="COCO数据集"></a>COCO数据集</h6><p>Base类48个，Novel17个，一共65个。</p>
<h6 id="多模态相关工作"><a href="#多模态相关工作" class="headerlink" title="多模态相关工作"></a>多模态相关工作</h6><p>CLIP、ALIGN、R2D2</p>
<h6 id="OVR-CNN"><a href="#OVR-CNN" class="headerlink" title="OVR-CNN"></a>OVR-CNN</h6><p>无类别区域检测器与无标注数据的跨模态模型</p>
<p><img src="/../images/ovd/image-20230627105546152.png" alt="image-20230627105546152"></p>
<p><img src="/../images/ovd/image-20230627110708030.png" alt="image-20230627110708030"></p>
<p>待看后两篇 <a href="https://mp.weixin.qq.com/s/f7hlh32TGPwktRhc64yejw">https://mp.weixin.qq.com/s/f7hlh32TGPwktRhc64yejw</a> </p>
]]></content>
      <tags>
        <tag>detect</tag>
      </tags>
  </entry>
  <entry>
    <title>hw</title>
    <url>/2023/06/27/hw/</url>
    <content><![CDATA[<h6 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h6><pre><code>
tree = struct(&#39;value&#39;, &#39;null&#39;, &#39;left&#39;, &#39;null&#39;, &#39;right&#39;, &#39;null&#39;);
相当于字典
值的索引是tree.value,用点的方式
#
length(attrib) attrib shape为150，5 返回150
索引是 attrib(:,1) 圆括号，从1开始
# 
bool数组对应的logical数组，可以用sum函数
#
</code></pre>
<h6 id="sortrows函数的使用："><a href="#sortrows函数的使用：" class="headerlink" title="sortrows函数的使用："></a>sortrows函数的使用：</h6><p>函数返回一个按照指定列排序后的矩阵或表格。如果两行在排序列中具有相同的值，则按照后续列进行排序。如果两行在所有列中都具有相同的值，则它们的顺序在结果中未定义。</p>
<p>例如，以下代码将一个3x3的矩阵按第二列进行排序：</p>
<p>A &#x3D; [4 3 9; 2 1 8; 7 6 5];<br>B &#x3D; sortrows(A, 2);</p>
<p>B &#x3D;<br>2 1 8<br>7 6 5<br>4 3 9</p>
<h6 id="cell-array"><a href="#cell-array" class="headerlink" title="cell array"></a>cell array</h6><pre><code>attri&#123;1,1&#125;=sortrows(attrib,1);
attri&#123;1,2&#125;=sortrows(attrib,2);
attri&#123;1,3&#125;=sortrows(attrib,3);
attri&#123;1,4&#125;=sortrows(attrib,4);
</code></pre>
<p>在Matlab中，<code>attri</code>的数据类型取决于 <code>sortrows</code> 函数的输出。根据代码中的赋值语句，我们可以猜测 <code>attri</code> 是一个单元格数组（cell array）。</p>
<p>单元格数组是Matlab中的一种数据类型，可以存储不同类型的数据，包括矩阵、向量、字符数组等等。它们可以通过花括号 <code>&#123;&#125;</code> 引用其中的元素，例如 <code>attri&#123;1,1&#125;</code> 就是单元格数组 <code>attri</code> 中第1行第1列元素的值。</p>
<p>在这个赋值语句中，<code>sortrows</code> 函数的输出是一个按第1列排序后的矩阵，然后将其赋值给 <code>attri&#123;1,1&#125;</code> 这个单元格数组的第1行第1列元素。因此，<code>attri</code> 的类型是单元格数组，而 <code>attri&#123;1,1&#125;</code> 的类型是矩阵。</p>
<h5 id="复杂语句"><a href="#复杂语句" class="headerlink" title="复杂语句"></a>复杂语句</h5><p>1:3 &#x3D; 1 2 3 开始与结束都包括</p>
<h6 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h6><pre><code class="matlab">for i = start:end
    ~
end
</code></pre>
<h6 id="逻辑判断符"><a href="#逻辑判断符" class="headerlink" title="逻辑判断符"></a>逻辑判断符</h6><p>不等于~&#x3D; </p>
]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>生成模型</title>
    <url>/2023/06/29/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5057b9112820d7395cbe1c7f38c24e6181012e2ac82551ee34fb6fe04422641f">7feab2e74e7ac8c26f5b44aac0c3756726ff17e5f378d5a54c6adfbf5c70da15b58222ea465b9890607a6c959423b0818f265f6d30eaddc92f49fdfbd01806eaabdefe1ba5ddaf53fa278beee8539cd0293d8ceb205c25c87dbd235933282f6c3f60e83cb5fe12b369eb82e2120434b623961fcebc543ed62a044dcc6b0c8210f99ae6df792d1dadae4d8c5389bb7c204a128326c89b175a862741406815d766ca060ea076e55e37f4e2e926939cf90e0bb86c59874af34ea7f433cae0a8bac83b5fc5571e7af7b70c5ede7364d6ccefc5b864503f0a6743a7c29d3b3e2c64f1f8221a703ba9c2095978a85d0cc5833faf380dfb9b3e553d64436353248ed7292d006862148e6663565aff60c5fc1a962461a2efad9a5d1bc8910a61fb925314324f38714f393189c05f33243fd34b22a3a469c28b825f51411c58a16bf7cf8ff24275bcab64e1aa23e61a3c34ef2d5a3c8f3b327d65ba2b49aa30ff4b285851a60d40fc78c62720d2d908139d0c87760d145d904b31146cddfdde1824e3b8a8efec3c53bf5084e892f564e8c23d5e7ff62efe015c0cf230b80df29accef9ab73cdfb095417fd981b122c03be0168b55e0b30ca0e67607cdc80d0091d72da593123053ab2bdc9e0584eb6656d974358d1fd03fcaa6777eb0169dbba49ac0983629f4462709af82467a5c5afc9b1c51060c74f55c53c9d1d84a5b1437f017ca195a6791efb8694d48c62b37d439d5499f71cd0f2ba59025a00a51bd8d1295a4e98ab72b84676987897fdd90feb013f12eb09f5d94c3c5f4abb505adf88aa2765e5d74610800653e06724216d17255278f9f7771f44153d75fc5487137de18060acfe0439980b163be21c2e0033be83b22dfdadb7e89fd82956844bcaba1423bda2e3dfad77ff80acee8cc2c36b952d2ab2fe7e5cdd9fd0d443917b83340a8b96157860123badca666ff09e225ca42f5325104dbfc7b8a29a03c3a46f6ff937fe4972bcf1ae9a2e507ff2447e4de5bae70057ee2f8674788c856f43d3df968d2013937f76d683f7f7542f58b6b5449bcd6c52a1244d47c407dc2a964ac701de30213ad080a4aada420fec518a9b25cb83fdef46f796390cde922b5f2c7fe9f8686a4ba9b8b34bf0a8f22c686328a16fd3f64274dde5fb473d4e430b689e6044af6dfb86d6b5e1b0b0d34a0f79e68a7e95811c989c5c096bc0dd5e22b063190e430cbd83503d524b0745fb178687a5b9ad47a3202b9a4722c2f042e0cefd29bec26309e4a44f8d28531d88efa91db16efde641aa467dd465737a71a5b98a7214585868b138fdf5ac8bf0862efd72e67b585d6bb80d3a86322046e0c29493508b22291c85f353ba352779dc8bd5de3ab79b09669b8875dcc4df0dd6ba28134f0fa3daee57043415990668ad0724d046e677b41a5d25e882753bfcfb9e8d9130d7bfe38eb5d88411f479a4762c57edd4d07d0b3329d34dbe576dea46d0b7f796a44a26cebce43e99a1fd975faba6e8dc9a3c4504384b14cbc2b74205911e12eae8fc39c71500e6431cb5dc1ea9869c65e18d8f8876f710ce384a0355d6dd9465ecfb7e25dba386f63ab7e2ae39cc1ac709345969f0c73d51d1680d94bb24ddc6130a93fc8053d589757c1ad491e03d2af7d5b1ce083b82f39c522d0d231558fd11bb29a7ac22e67398613011faa11988605acd6aecd0b6ad20d20c31a9db6ad597a25a67530f9349bb060064ffeab4d6851eeea70be1c932cb5b0bcb54a1888a942cee462dced23072c096125bb0133a99b8327440e8977b3e886a3ae9581bce18aeb1f5ca8a1441ac16749fb303951a904bdada863f5810aa764a89cce607d35348ee7f99e509aff5017ddc8ee9e4055e92b171c7a70cb13cae5d1bd426fea44f3f403c1495dfec7139f0082359bedb44c44050199117383501ecc2e3556856665ec11f0628ef402aa4e4cede4edd28d1b679328fdd4d347e2f9c1ed07a3b0d8b7d7b597a26537cd0792999639179e63fcf20c162982a5d4501fd2ce87ef77c4ddfaab79bcda213c71ef277e0bcdc519db33aabdf67f36603a58e287f055a170f15121878925c252e60da5523f80650f542cb25e5585e7f4dee7095e905605d7beb0fa4f8e990f06dca44e043fa20cc7c3f7ceab55b326dce0b91615f1e0b6d616e9f9018bd4736dd178edf992ff4ba78e6b8acefbde86a6c199726bde7f987ec6d3bc0874d14f69f66912a30bedd2b9e32bc34fb1d80a901ed15c80f62981e061164ac7db2f510fbfe592881ccb4f06a20991f68df3ca4f2e445e791d3aa346d9f9ab1f20515e1a3a121cbb852866425a5d86587420cf6ca4a3022b8eb55a999b78c62ce7352aec9e8bb3898819644e00c77b2abfeeb264c81e65b8c5e8911c5aa31039cc665f280169fd87e973b1eba56f15c2968e3393824d5392032f9ea11f0ee7f3794a73d4b2380ae2b98d78c75acdd33e344e57310be7dc221a2a30caec9c83332ac8afb71abda834e7a19074e8f674fa6cfeb811fca04a59649ad5e0232427d8dc61c2571a01907341dc2f4c0c09fbdce33e414214760dbdb1a5dff463c33509ef7b140b2ce354a0c887f32799d68031eefa101179476075c23793b916f7d7ff57b1afd6270d49626dac23422540d953de7eb061ed09ec8361526378323a05e0b3fe764875a5daddb5fdb6d1125f9c6b48d2e4e903d6a999408ce0f23bbae10e0b42f1b88431aa6b4f44a7da1a14d11b7a2196c01c4b8841f6ea6e9290254677e5bd196a1c62d9037c8fd7ef4d4f2314c84fb04af06e0c23ef85246572ce8823cfc23220cb289d578005ea76fffb7f35a4a3f1f6de98fef91dd4ce9321a7818d2efd63e9bdc8b97566275a542cc03e26779b8ae714bb58bfb1f43d664a275281ce959c1baac0126295dfbf873fe244b874d85b1d0de6ab73426f82f4c9522ef583c530894052f57da2cf56956e3c0689267fdbc3637a1009128c20fe0b869871b5c3fd032fdb9bb9ecb9cf02e62563885eca760b86ce9db8f1ab8979d7219d3ee650175d707f05a8a5aabc6e62dc5fdd7156fa9e0ab6737dcddb7528ad708d4cdacf04fbe0bf4934189445780ab53e758f21a9235f4fe3f58f126eaa9634659783be40c16be5999d8d1932f70f38979026b6c5cf95558ed6f70739e750a118dd5ac9e193126531a43491999c50b08cf224a436e2ea5b6082d82836b8203a6fad36bad0724f5ee56d3799963341c4d19ef905c643fe80ddc44bb4ee9ae955</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>生成模型</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建</title>
    <url>/2023/07/05/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><h6 id="多视图三维重建的传统流程"><a href="#多视图三维重建的传统流程" class="headerlink" title="多视图三维重建的传统流程"></a>多视图三维重建的传统流程</h6><ul>
<li><p>多视图三维重建的传统流程：</p>
</li>
<li><p>图像特征匹配，SfM求解相机位姿，MVS稠密重建</p>
<p>相机位姿（Camera Pose）是指相机在三维空间中的位置和朝向,旋转矩阵和一个平移向量来描述相机位姿为了实现MVS稠密重建，</p>
<p>MVS 稠密重建通常包括以下步骤：</p>
<ol>
<li>xxxxxxxxxx if torch.cuda.is_available():    model.cuda()python</li>
<li>基础矩阵和本质矩阵估计。使用特征点匹配，可以估计相邻图像之间的基础矩阵或本质矩阵，这些矩阵描述了相机之间的几何关系，包括旋转和平移。</li>
<li>稠密点云重建。根据相邻图像之间的几何关系，可以将每个像素点从图像坐标系转换到世界坐标系。将这些点云数据结合起来，可以得到一个稠密的点云模型。</li>
<li>点云表面重建。稠密点云中包含大量的噪声和无用点，需要进行过滤和表面重建，得到一个光滑的表面模型。</li>
</ol>
<p>需要进行以下步骤：</p>
</li>
</ul>
<ol>
<li>相机位姿估计：利用SfM技术估计每个视角的相机位姿。</li>
<li>立体匹配：对于每个像素点，利用多个视角的图像进行立体匹配，估计该像素点在三维空间中的位置。</li>
<li>三维重建：将所有像素点的三维位置整合起来，重建出整个物体的三维几何形状。</li>
</ol>
<ul>
<li>缺点：重建流程<a href="https://www.zhihu.com/search?q=%E9%B2%81%E6%A3%92%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2648027035%7D">鲁棒性</a>差，不可导：无反馈机制</li>
</ul>
<h6 id="基于表示学习的图像特征匹配："><a href="#基于表示学习的图像特征匹配：" class="headerlink" title="基于表示学习的图像特征匹配："></a>基于表示学习的图像特征匹配：</h6><ul>
<li>​	SuperPoint，SuperGlue、ORB</li>
</ul>
<p>SuperPoint具有更快的速度和更好的鲁棒性。SuperPoint使用卷积神经网络来学习特征表示，其中包括特征点的位置、尺度和方向，以及对应的描述子。</p>
<p>SuperGlue是一种基于深度学习的图像特征匹配算法，它可以通过对两个图像中提取的特征进行匹配，找到它们之间的对应关系和相对位姿。</p>
<p>LoFTR：Detector-free Local Feature Matching with Transformers是一种detector-free的特征匹配算法，它不需要使用传统的特征检测器来提取局部特征点</p>
<h6 id="基于神经表示学习的三维场景重建"><a href="#基于神经表示学习的三维场景重建" class="headerlink" title="基于神经表示学习的三维场景重建"></a>基于神经表示学习的三维场景重建</h6><ul>
<li>重建流程：1. 比较渲染图像雨输入图像，计算误差。 2.通过梯度回传修改网络参数，优化隐式神经表示待解决问题：</li>
<li>隐式神经表示重建<strong>（采样）</strong>效率低下，难以扩展到大规模场景室内弱纹理区域缺乏足够约束，隐式神经表示重建成为病态话问题</li>
</ul>
<h6 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h6><p>Neural Reconsturction in the Wild</p>
<ul>
<li>核心思想：表面引导的层次化采样，基于互联网图像进行场景重建核心思想：平面先验</li>
</ul>
<p>基于神经表示学习的动态人体重建<br>    动态人体重建传统方案通过稠密相机阵列逐帧重建Neural Body<br>挑战：如何减少输入视点的数量<br>从稀疏的输入视图重建神经表示是病态问题</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>核心思想：整合时序观测，假设不同时刻的观测来自于同一组隐编码</p>
<p>挑战：如何建模多人场景核心</p>
<p>思想：同步重建与分割</p>
<p>二维图像特征表示学习   -〉更鲁邦的图像匹配和位姿估计</p>
<p>三维几何&#x2F;外观表示学习 -〉更鲁棒更高质量的三维重建</p>
<p>NGP</p>
<h5 id="Nerf"><a href="#Nerf" class="headerlink" title="Nerf"></a>Nerf</h5><p><a href="https://yconquesty.github.io/blog/ml/nerf/">https://yconquesty.github.io/blog/ml/nerf/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/631284285">https://zhuanlan.zhihu.com/p/631284285</a></p>
<p>NeRF,neural radiance field，翻译为神经辐射场</p>
<p><img src="https://pic2.zhimg.com/v2-6bf894d1fd88981551751cf4337b931d_b.jpg"></p>
<p>Instant-NGP的pipeline</p>
<p><img src="https://pic1.zhimg.com/v2-4e7016eb074496cf0235a7ff685d8c24_r.jpg"></p>
]]></content>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>杂</title>
    <url>/2023/07/06/%E6%9D%82/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_43863869/article/details/125002909">https://blog.csdn.net/weixin_43863869/article/details/125002909</a></p>
<ul>
<li><code>/etc/environment</code>：系统级环境变量文件，适用于所有用户和进程。</li>
<li><code>~/.bashrc</code>：登录shell级别的环境变量文件，适用于当前用户和其子进程。</li>
<li><code>~/.bash_profile</code>：登录shell级别的环境变量文件，仅适用于当前用户。</li>
<li><code>~/.profile</code>：登录shell级别的环境变量文件，仅适用于当前用户。</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_45837114/article/details/128255248">https://blog.csdn.net/weixin_45837114/article/details/128255248</a></p>
<h6 id="合成视频"><a href="#合成视频" class="headerlink" title="合成视频"></a>合成视频</h6><pre><code>import cv2
import numpy as np

videoLeft = cv2.VideoCapture(&#39;C:\\Users\\USTC\\Desktop\\debug_pose\\PRED\\0000\\all_frame.mp4&#39;)
videoRight = cv2.VideoCapture(&#39;C:\\Users\\USTC\\Desktop\\debug_pose\\GT\\0000\\all_frame.mp4&#39;)

fps = videoLeft.get(cv2.CAP_PROP_FPS)

width = (int(videoLeft.get(cv2.CAP_PROP_FRAME_WIDTH)))
height = (int(videoLeft.get(cv2.CAP_PROP_FRAME_HEIGHT)))

videoWriter = cv2.VideoWriter(&#39;C:\\Users\\USTC\\Desktop\\debug_pose\\GT\\output.mp4&#39;, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;), fps, (width*2, height))

successLeft, frameLeft = videoLeft.read()
successRight, frameRight = videoRight.read()

while successLeft and successRight:
    frameLeft = cv2.resize(frameLeft, (width, height), interpolation=cv2.INTER_CUBIC)
    frameRight = cv2.resize(frameRight, (width, height), interpolation=cv2.INTER_CUBIC)

    frame = np.hstack((frameLeft, frameRight))

    videoWriter.write(frame)

    successLeft, frameLeft = videoLeft.read()
    successRight, frameRight = videoRight.read()

videoWriter.release()
videoLeft.release()
videoRight.release()
</code></pre>
]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>多GPU训练</title>
    <url>/2023/07/08/%E5%A4%9AGPU%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/157976140">https://zhuanlan.zhihu.com/p/157976140</a></p>
<h5 id="一机多卡训练"><a href="#一机多卡训练" class="headerlink" title="一机多卡训练"></a>一机多卡训练</h5><pre><code class="python">import torch.distributed
</code></pre>
<h6 id="初始化后端"><a href="#初始化后端" class="headerlink" title="初始化后端"></a>初始化后端</h6><pre><code class="python">local_rank = args.local_rank
torch.cuda.set_device(local_rank)
torch.distributed.init_process_group(backend=&#39;nccl&#39;, init_method=&#39;env://&#39;)
</code></pre>
<h6 id="模型并行化"><a href="#模型并行化" class="headerlink" title="模型并行化"></a>模型并行化</h6><pre><code class="python">model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[local_rank], output_device=local_rank)
</code></pre>
<h6 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h6><pre><code class="python">sampler = torch.utils.data.distributed.DistributedSampler(dataset)
rand_loader = DataLoader(dataset=dataset,batch_size=batch_size, shuffle=False, sampler=sampler)
</code></pre>
<h6 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h6><pre><code>python -m torch.distributed.launch --nproc_per_node=6 run_mvp_train_DDP_threepeople.py --overlap_slide
</code></pre>
<pre><code class="python">python -m torch.distributed.launch --nproc_per_node=8 train_face_troch.py
</code></pre>
<pre><code class="python">def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;--local_rank&#39;, default=0, type=int)
    args = parser.parse_args()
    return args
</code></pre>
<pre><code class="python">model, optimizer = amp.initialize(model, optimizer, opt_level=&#39;O1&#39;)  # 这里是字母O
</code></pre>
<pre><code class="python">if torch.cuda.is_available():
    model.cuda()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>POSE</title>
    <url>/2023/07/13/POSE/</url>
    <content><![CDATA[<h1 id="RLE"><a href="#RLE" class="headerlink" title="RLE"></a>RLE</h1><p><a href="https://zhuanlan.zhihu.com/p/625023463">https://zhuanlan.zhihu.com/p/625023463</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/440567782">https://zhuanlan.zhihu.com/p/440567782</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/429017412">https://zhuanlan.zhihu.com/p/429017412</a> 讲的最好的文章</p>
<p><a href="https://github.com/Jeff-sjtu/res-loglikelihood-regression">https://github.com/Jeff-sjtu/res-loglikelihood-regression</a></p>
<p><a href="https://www.bilibili.com/video/BV18E411w7Jh/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV18E411w7Jh/?spm_id_from=333.999.0.0</a> 讲flow的视频</p>
<p>GAN训练：模式崩溃和后置崩溃挑战</p>
<p><a href="https://zhuanlan.zhihu.com/p/165577850">https://zhuanlan.zhihu.com/p/165577850</a> flow的文章</p>
<p><a href="https://zhuanlan.zhihu.com/p/59615785">https://zhuanlan.zhihu.com/p/59615785</a> 讲flow的文章</p>
<pre><code>20个采样点 10个实列
all number of params: 43108693
number of backbone params: 33841352
其余的9267341
</code></pre>
<pre><code>20个采样点 5个实列
all number of params: 43105908
number of backbone params: 33841352
</code></pre>
<pre><code>10个采样点 5个实列
all number of params: 42365748
number of backbone params: 33841352
</code></pre>
<p>19416917</p>
<p>尺寸不变</p>
<pre><code>kernel_size=3, padding=1, stride=1 
kernel_size=5, padding=2, stride=1
kernel_size=7, padding=3, stride=1
</code></pre>
<h1 id="与姿态相关的论文主要看数据组织结构"><a href="#与姿态相关的论文主要看数据组织结构" class="headerlink" title="与姿态相关的论文主要看数据组织结构"></a>与姿态相关的论文主要看数据组织结构</h1><h2 id="DAS"><a href="#DAS" class="headerlink" title="DAS"></a>DAS</h2><pre><code>$&#123;ROOT&#125;
|-- data
|   |-- panoptic
|   |   |-- 160226_haggling1
|   |   |   |-- hdImgs
|   |   |   |   |-- 00_16
|   |   |   |   |-- 00_30
|   |   |-- 160422_haggling1
|   |   |-- 160226_mafia1
|   |   |-- 160422_mafia2
|   |   |-- 160226_ultimatum1
|   |   |-- 160422_ultimatum1
|   |   |-- 160906_pizza1
|   |   |-- annotations
|   |   |   |-- train.json
|   |   |   |-- haggling.json
|   |   |   |-- mafia.json
|   |   |   |-- ultimatum.json
|   |   |   |-- pizza.json
|   |-- coco
|   |   |-- train2017
|   |   |-- annotations
|   |   |   |-- person_keypoints_train2017.json
|   |-- muco
|   |   |-- unaugmented_set
|   |   |-- augmented_set
|   |   |-- annotations
|   |   |   |-- train_all_interv1.json
|   |-- mupots
|   |   |-- TS1
|   |   |   |-- img_000000.jpg
|   |   |   |-- ...
|   |   |-- ...
|   |   |-- TS20
|   |   |-- annotations
|   |   |   |-- MuPoTS-3D.json
</code></pre>
<h2 id="voxel-pose"><a href="#voxel-pose" class="headerlink" title="voxel_pose"></a>voxel_pose</h2><pre><code>$&#123;POSE_ROOT&#125;
|-- models
|   |-- pose_resnet50_panoptic.pth.tar
|-- data
    |-- panoptic-toolbox
        |-- data
            |-- 16060224_haggling1
            |   |-- hdImgs
            |   |-- hdvideos
            |   |-- hdPose3d_stage1_coco19
            |   |-- calibration_160224_haggling1.json
            |-- 160226_haggling1  
            |-- ...
</code></pre>
<h2 id="PCT"><a href="#PCT" class="headerlink" title="PCT"></a>PCT</h2><pre><code>$&#123;POSE_ROOT&#125;
|-- data
`-- |-- coco
    `-- |-- annotations
        |   |-- person_keypoints_train2017.json
        |   `-- person_keypoints_val2017.json
        |-- person_detection_results
        |   |-- COCO_val2017_detections_AP_H_56_person.json
        |   |-- COCO_test-dev2017_detections_AP_H_609_person.json
        `-- images
            |-- train2017
            |   |-- 000000000009.jpg
            |   |-- 000000000025.jpg
            |   |-- 000000000030.jpg
            |   |-- ... 
            `-- val2017
                |-- 000000000139.jpg
                |-- 000000000285.jpg
                |-- 000000000632.jpg
                |-- ... 
</code></pre>
<h2 id="GFPose"><a href="#GFPose" class="headerlink" title="GFPose"></a>GFPose</h2><pre><code>$&#123;POSE_ROOT&#125;
|-- configs
|-- lib
|-- run
|-- checkpoint
    |-- u3d
        |-- best_model.pth
|-- data
    |-- h36m
        |-- h36m_train.pkl
        |-- h36m_test.pkl
        |-- h36m_sh_dt_ft.pkl
</code></pre>
<h1 id="姿态相关的评价指标"><a href="#姿态相关的评价指标" class="headerlink" title="姿态相关的评价指标"></a>姿态相关的评价指标</h1><h2 id="3D-Percentage-of-Correct-Keypoints"><a href="#3D-Percentage-of-Correct-Keypoints" class="headerlink" title="3D Percentage of Correct Keypoints"></a>3D Percentage of Correct Keypoints</h2><p><a href="https://blog.csdn.net/StupidAutofan/article/details/125436224">https://blog.csdn.net/StupidAutofan/article/details/125436224</a></p>
<h2 id="PCK-rel"><a href="#PCK-rel" class="headerlink" title="PCK_rel"></a>PCK_rel</h2><p>对齐后的坐标系</p>
<h2 id="PCK-abs"><a href="#PCK-abs" class="headerlink" title="PCK_abs"></a>PCK_abs</h2><p>0号相机对应的坐标系</p>
<h1 id="姿态相关的数据"><a href="#姿态相关的数据" class="headerlink" title="姿态相关的数据"></a>姿态相关的数据</h1><h2 id="CrowdPose"><a href="#CrowdPose" class="headerlink" title="CrowdPose"></a>CrowdPose</h2><h2 id="OCHuman"><a href="#OCHuman" class="headerlink" title="OCHuman"></a>OCHuman</h2><h2 id="SyncOCC"><a href="#SyncOCC" class="headerlink" title="SyncOCC"></a>SyncOCC</h2><p>合成的数据</p>
<h2 id="MPII"><a href="#MPII" class="headerlink" title="MPII"></a>MPII</h2><p>The dataset includes around <strong>25K images</strong> containing over <strong>40K people</strong> with annotated body joints；</p>
<p><strong>410 human activities</strong> and each image is provided with an activity label；</p>
<p>POSENET也有下载链接，组织为</p>
<pre><code>|   |-- MPII
|   |   |-- images
|   |   |-- annotations
</code></pre>
<p>官网也有</p>
<p><a href="http://human-pose.mpi-inf.mpg.de/#download">http://human-pose.mpi-inf.mpg.de/#download</a></p>
<h2 id="CMU-Panoptic"><a href="#CMU-Panoptic" class="headerlink" title="CMU Panoptic"></a>CMU Panoptic</h2><p><a href="http://domedb.perception.cs.cmu.edu/">http://domedb.perception.cs.cmu.edu/</a> 数据主页</p>
<p><a href="https://github.com/CMU-Perceptual-Computing-Lab/panoptic-toolbox">https://github.com/CMU-Perceptual-Computing-Lab/panoptic-toolbox</a></p>
<p>31个 多视角HD video（高清视频）通常指 1080p（1920x1080 像素）或更高分辨率的视频。</p>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><p>下载这个PanopticStudio Toolbox，然后</p>
<pre><code>./scripts/getData.sh 171204_pose1_sample 举列子
./scripts/getData.sh 171204_pose1

./scripts/getData.sh (sequenceName) (VGA_Video_Number) (HD_Video_Number)
列如./scripts/getData.sh 171204_pose1_sample 240 10 
240 vga videos and 10 videos.

可选的序列名称
https://docs.google.com/spreadsheets/d/1eoe74dHRtoMVVFLKCTJkAtF8zqxAnoo2Nt15CYYvHEE/edit#gid=1333444170

./scripts/getDB_panopticHD_ver1_2.sh
下载1.2数据版本所有数据
上述命令默认是不下载视频数据的，就要像上面一样指定视频个数

假如说现在下载好了视频，需要将视频变成每一帧每一帧的，然后将一视频的标签也变成一帧一帧图片对应的pose;注需要ffmpeg
运行这个命令有
./scripts/extractAll.sh 171204_pose1_sample
171204_pose1_sample/hdImgs/00_00/00_00_00000000.jpg
171204_pose1_sample/hdPose3d_stage1_coco19/body3DScene_00000000.json

在这个工具里面有一些可视化的代码，以及从3D重投影到2D的方法
还有一些kinect数据点云的

注：https://github.com/wangzt-halo/das在DAS这个项目有一个代码可以将原始标签转化
</code></pre>
<p>480 views VGA video（标准视频）是指分辨率为 640x480 像素的视频。</p>
<ul>
<li>171204_pose1_sample&#x2F;hdVideos&#x2F;hd_00_XX.mp4  #synchronized HD video files (31 views)</li>
<li>171204_pose1_sample&#x2F;vgaVideos&#x2F;KINECTNODE%d&#x2F;vga_XX_XX.mp4 #synchrponized VGA video files (480 views)</li>
<li>171204_pose1_sample&#x2F;calibration_171204_pose1_sample.json #calibration files</li>
<li>171204_pose1_sample&#x2F;hdPose3d_stage1_coco19.tar #3D Body Keypoint Data (coco19 keypoint definition)</li>
<li>171204_pose1_sample&#x2F;hdFace3d.tar #3D Face Keypoint Data</li>
<li>171204_pose1_sample&#x2F;hdHand3d.tar #3D Hand Keypoint Data</li>
</ul>
<h2 id="COCO-keypoint数据"><a href="#COCO-keypoint数据" class="headerlink" title="COCO keypoint数据"></a>COCO keypoint数据</h2><p>150K训练5K验证30K测试</p>
<img src="../images/POSE/image-20230721142637523.png" alt="image-20230721142637523" style="zoom:80%;" />

<img src="../images/POSE/image-20230721142828338.png" alt="image-20230721142828338" style="zoom:50%;" />

<img src="../images/POSE/image-20230721142920961.png" alt="image-20230721142920961" style="zoom:80%;" />



<h2 id="MuPoTS"><a href="#MuPoTS" class="headerlink" title="MuPoTS"></a>MuPoTS</h2><p>20 video sequences,Each video has up to 3 subjects.</p>
<p>POSENET组织格式</p>
<p>POSENET也有下载链接</p>
<pre><code>|   |-- MuPoTS
|   |   |-- bbox_root
|   |   |   |-- bbox_mupots_output.json
|   |   |-- data
|   |   |   |-- MultiPersonTestSet
|   |   |   |-- MuPoTS-3D.json
</code></pre>
<h2 id="MuCo"><a href="#MuCo" class="headerlink" title="MuCo"></a>MuCo</h2><p>这些图像是通过从单人 3D 姿态估计数据集 MPI-INF-3DHP [19] 中随机合成人来生成的。</p>
<p>POSENET组织格式</p>
<p>POSENET也有下载链接</p>
<pre><code>|   |-- MuCo
|   |   |-- data
|   |   |   |-- augmented_set
|   |   |   |-- unaugmented_set
|   |   |   |-- MuCo-3DHP.json
</code></pre>
<h2 id="MPI-INF-3DHP"><a href="#MPI-INF-3DHP" class="headerlink" title="MPI-INF-3DHP"></a>MPI-INF-3DHP</h2><h2 id="Human-3-6使用"><a href="#Human-3-6使用" class="headerlink" title="Human 3.6使用"></a>Human 3.6使用</h2><h3 id="数据标签格式"><a href="#数据标签格式" class="headerlink" title="数据标签格式"></a>数据标签格式</h3><pre><code>
    Pelvis（骨盆）
    R_Hip（右髋）
    R_Knee（右膝）
    R_Ankle（右踝）
    L_Hip（左髋）
    L_Knee（左膝）
    L_Ankle（左踝）
    Torso（躯干）
    Neck（颈部）
    Nose（鼻子）
    Head（头部）
    L_Shoulder（左肩）
    L_Elbow（左肘）
    L_Wrist（左腕）
    R_Shoulder（右肩）
    R_Elbow（右肘）
    R_Wrist（右腕）
    Thorax（胸部）
</code></pre>
<h4 id="json-RLE-："><a href="#json-RLE-：" class="headerlink" title="json(RLE)："></a>json(RLE)：</h4><img src="../images/POSE/image-20230727144953267.png" alt="image-20230727144953267" style="zoom:80%;" />

<p>这里的action_name对应action_idx</p>
<p> action_name &#x3D; [‘Directions’, ‘Discussion’, ‘Eating’, ‘Greeting’, ‘Phoning’, ‘Posing’, ‘Purchases’,</p>
<p>​          ‘Sitting’, ‘SittingDown’, ‘Smoking’, ‘Photo’, ‘Waiting’, ‘Walking’, ‘WalkDog’, ‘WalkTogether’]</p>
<p>关于相机标定参数:</p>
<p>R是3*3的矩阵，</p>
<p>t是3*1的矩阵</p>
<p>f,c是2*1的矩阵</p>
<p><img src="/../images/POSE/image-20230727145435923.png" alt="image-20230727145435923"></p>
<p>世界坐标系下的关键点个数是18,3</p>
<img src="../images/POSE/image-20230727145519612.png" alt="image-20230727145519612" style="zoom:50%;" />



<img src="../images/POSE/image-20230727145553510.png" alt="image-20230727145553510" style="zoom:50%;" />

<img src="../images/POSE/image-20230727145617817.png" alt="image-20230727145617817" style="zoom:50%;" />



<p>这里的bbox是xywh</p>
<img src="../images/POSE/image-20230727145635388.png" alt="image-20230727145635388" style="zoom:50%;" />





<p>原始数据下载</p>
<p><a href="https://blog.csdn.net/qq_42951560/article/details/126380971">https://blog.csdn.net/qq_42951560/article/details/126380971</a></p>
<h3 id="POSENET组织格式"><a href="#POSENET组织格式" class="headerlink" title="POSENET组织格式"></a>POSENET组织格式</h3><p>POSENET也有下载链接</p>
<p><a href="https://github.com/mks0601/3DMPPE_POSENET_RELEASE">https://github.com/mks0601/3DMPPE_POSENET_RELEASE</a></p>
<pre><code>|   |-- Human36M
|   |   |-- bbox_root
|   |   |   |-- bbox_root_human36m_output.json
|   |   |-- images
|   |   |-- annotations
</code></pre>
<h3 id="RLE组织格式"><a href="#RLE组织格式" class="headerlink" title="RLE组织格式"></a>RLE组织格式</h3><pre><code>    |-- h36m
    `-- |-- annotations
        |   |-- Sample_trainmin_train_Human36M_protocol_2.json
        |   `-- Sample_64_test_Human36M_protocol_2.json
        `-- images
            |-- s_01_act_02_subact_01_ca_01
            |   |-- ...
            |-- s_01_act_02_subact_01_ca_02
            |   |-- ...
            `-- ... 
</code></pre>
<p>Human3.6是没有遮挡的数据的</p>
<p>18个关节点</p>
<p>Pixel-level 24 body part labels for each configuration</p>
<p>Time-of-flight range data 测距的数据</p>
<p>3D laser scans of the actors mesh数据</p>
<p><a href="http://vision.imar.ro/human3.6m/description.php">http://vision.imar.ro/human3.6m/description.php</a></p>
<p>对于测距以及mesh的数据的描述</p>
<p>pose数据还包括relative 3D joint positions (R3DJP)和kinematic representation (KR)，KR用于描述物体的运动状态，例如位置、速度和加速度等。</p>
<img src="../images/POSE/image-20230721143257782.png" alt="image-20230721143257782" style="zoom:50%;" />

<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/h36m_annot.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/h36m_annot.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S1.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S1.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S5.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S5.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S6.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S6.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S7.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S7.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S8.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S8.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S9.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S9.tar</a></p>
<p><a href="http://visiondata.cis.upenn.edu/volumetric/h36m/S11.tar">http://visiondata.cis.upenn.edu/volumetric/h36m/S11.tar</a></p>
<h1 id="学习RLE代码"><a href="#学习RLE代码" class="headerlink" title="学习RLE代码"></a>学习RLE代码</h1><h3 id="Train-on-MSCOCO"><a href="#Train-on-MSCOCO" class="headerlink" title="Train on MSCOCO"></a>Train on MSCOCO</h3><pre><code>./scripts/train.sh ./configs/256x192_res50_regress-flow.yaml train_rle_coco
</code></pre>
<p>train.sh里面的内容为：</p>
<pre><code>set -x
# 可以打开shell的调试模式，以便在shell执行时输出每个命令和其参数的执行结果。
CONFIG=$1 # 这将第一个命令行参数（$1）的值赋给名为CONFIG的变量。
EXPID=$&#123;2:-&quot;test_rle&quot;&#125; #  这将第二个命令行参数（$2）的值赋给名为EXPID的变量。如果第二个参数未提供，则						   #  EXPID的值将为&quot;test_rle&quot;。
PORT=$&#123;3:-23456&#125;
HOST=$(hostname -i)

python ./scripts/train.py --nThreads 16 \
    --launcher pytorch --rank 0 \
    --dist-url tcp://$&#123;HOST&#125;:$&#123;PORT&#125; \
    --exp-id $&#123;EXPID&#125; \
    --cfg $&#123;CONFIG&#125; --seed 123123
</code></pre>
<h3 id="写代码的技巧"><a href="#写代码的技巧" class="headerlink" title="写代码的技巧"></a>写代码的技巧</h3><h4 id="opt-snapshot"><a href="#opt-snapshot" class="headerlink" title="opt.snapshot"></a>opt.snapshot</h4><h4 id="‘pytorch’-‘slurm’-‘mpi’分布式平台"><a href="#‘pytorch’-‘slurm’-‘mpi’分布式平台" class="headerlink" title="‘pytorch’, ‘slurm’, ‘mpi’分布式平台"></a>‘pytorch’, ‘slurm’, ‘mpi’分布式平台</h4><h4 id="对于某些模块的特定初始化"><a href="#对于某些模块的特定初始化" class="headerlink" title="对于某些模块的特定初始化"></a>对于某些模块的特定初始化</h4><p>1.如果没有写在__init__里面写到类某个函数里面</p>
<p>如下面</p>
<pre><code>    def _initialize(self):
        for m in self.fcs:
            if isinstance(m, nn.Linear):
                nn.init.xavier_uniform_(m.weight, gain=0.01)
        for m in self.fc_layers:
            if isinstance(m, nn.Linear):
                nn.init.xavier_uniform_(m.weight, gain=0.01)
</code></pre>
<p>则要在类实列化后再使用model._initialize(),调用这个函数</p>
<h4 id="注册器类似于mmcv"><a href="#注册器类似于mmcv" class="headerlink" title="注册器类似于mmcv"></a>注册器类似于mmcv</h4><p>先弄一个Registry,属性有一个名字与一个字典，里面定义一个修饰器register_module，使用的时候如下</p>
<p>下面这段代码位于rlepose&#x2F;models&#x2F;<strong>init</strong>.py,在初始化的时候变导入啦</p>
<pre><code>@SPPE.register_module
class RegressFlow3D(nn.Module):
    pass
</code></pre>
<p>这样SPPE这个修饰器下面，属性字典里面就有一个key为RegressFlow3D,value为这个类对象的。</p>
<h4 id="损失类型"><a href="#损失类型" class="headerlink" title="损失类型"></a>损失类型</h4><h5 id="MSELoss"><a href="#MSELoss" class="headerlink" title="MSELoss"></a>MSELoss</h5><pre><code>@LOSS.register_module
class MSELoss(nn.Module):
    &#39;&#39;&#39; MSE Loss
    &#39;&#39;&#39;
    def __init__(self):
        super(MSELoss, self).__init__()
        self.criterion = nn.MSELoss()

    def forward(self, output, labels):
        pred_hm = output[&#39;heatmap&#39;]
        gt_hm = labels[&#39;target_hm&#39;]
        gt_hm_weight = labels[&#39;target_hm_weight&#39;]
        loss = 0.5 * self.criterion(pred_hm.mul(gt_hm_weight), gt_hm.mul(gt_hm_weight))

        return loss
</code></pre>
<h5 id="RLELoss"><a href="#RLELoss" class="headerlink" title="RLELoss"></a>RLELoss</h5><pre><code>class RLELoss(nn.Module):
    &#39;&#39;&#39; RLE Regression Loss
    &#39;&#39;&#39;

    def __init__(self, OUTPUT_3D=False, size_average=True):
        super(RLELoss, self).__init__()
        self.size_average = size_average
        self.amp = 1 / math.sqrt(2 * math.pi)

    def logQ(self, gt_uv, pred_jts, sigma):
        return torch.log(sigma / self.amp) + torch.abs(gt_uv - pred_jts) / (math.sqrt(2) * sigma + 1e-9)

    def forward(self, output, labels):
        nf_loss = output.nf_loss
        pred_jts = output.pred_jts
        sigma = output.sigma
        gt_uv = labels[&#39;target_uv&#39;].reshape(pred_jts.shape)
        gt_uv_weight = labels[&#39;target_uv_weight&#39;].reshape(pred_jts.shape)

        nf_loss = nf_loss * gt_uv_weight[:, :, :1]

        residual = True
        if residual:
            Q_logprob = self.logQ(gt_uv, pred_jts, sigma) * gt_uv_weight
            loss = nf_loss + Q_logprob

        if self.size_average and gt_uv_weight.sum() &gt; 0:
            return loss.sum() / len(loss)
        else:
            return loss.sum()
</code></pre>
<h5 id="RLELoss3D"><a href="#RLELoss3D" class="headerlink" title="RLELoss3D"></a>RLELoss3D</h5><pre><code>class RLELoss3D(nn.Module):
    &#39;&#39;&#39; RLE Regression Loss 3D
    &#39;&#39;&#39;

    def __init__(self, OUTPUT_3D=False, size_average=True):
        super(RLELoss3D, self).__init__()
        self.size_average = size_average
        self.amp = 1 / math.sqrt(2 * math.pi)

    def logQ(self, gt_uv, pred_jts, sigma):
        return torch.log(sigma / self.amp) + torch.abs(gt_uv - pred_jts) / (math.sqrt(2) * sigma + 1e-9)

    def forward(self, output, labels):
        nf_loss = output.nf_loss
        pred_jts = output.pred_jts
        sigma = output.sigma
        gt_uv = labels[&#39;target_uvd&#39;].reshape(pred_jts.shape)
        gt_uv_weight = labels[&#39;target_uvd_weight&#39;].reshape(pred_jts.shape)
        nf_loss = nf_loss * gt_uv_weight

        residual = True
        if residual:
            Q_logprob = self.logQ(gt_uv, pred_jts, sigma) * gt_uv_weight
            loss = nf_loss + Q_logprob

        if self.size_average and gt_uv_weight.sum() &gt; 0:
            return loss.sum() / len(loss)
        else:
            return loss.sum()
</code></pre>
<h4 id="SimpleTransform3D-object"><a href="#SimpleTransform3D-object" class="headerlink" title="SimpleTransform3D(object):"></a>SimpleTransform3D(object):</h4><pre><code>self.transformation = SimpleTransform3D(
self, 
scale_factor=self._scale_factor,  	# 0.3
color_factor=self._color_factor,	# 0.2
occlusion=self._occlusion,			# True
input_size=self._input_size,		# 256,256
output_size=self._output_size,		# 64,64
bbox_3d_shape=self.bbox_3d_shape,	# (2000, 2000, 2000)
rot=self._rot,						# 30
sigma=self._sigma,					# 2
train=self._train,					# true
add_dpg=self._dpg,					# false
loss_type=self._loss_type,			# &#39;coord&#39;
scale_mult=1)						
</code></pre>
<h4 id="class-H36m-data-Dataset"><a href="#class-H36m-data-Dataset" class="headerlink" title="class H36m(data.Dataset):"></a>class H36m(data.Dataset):</h4><pre><code>self._items, self._labels = self._lazy_load_json()
def _lazy_load_json(self):
     items, labels = self._load_jsons()
     
def _load_jsons(self):
    items = []
    labels = []	
    for ann_image, ann_annotations in zip(database[&#39;images&#39;], database[&#39;annotations&#39;]):     	#每一张图片
        items.append(abs_path)
                    labels.append(&#123;
                &#39;bbox&#39;: (xmin, ymin, xmax, ymax),   # bbox_clip_xyxy
                &#39;img_id&#39;: image_id,
                &#39;img_path&#39;: abs_path,               # 图片绝对路径
                &#39;width&#39;: width,
                &#39;height&#39;: height,
                &#39;joint_img&#39;: joint_img,             # 一个相对的，相对中root关节点的坐标值，x,y不是相对的，z轴是相对的
                &#39;joint_vis&#39;: joint_vis,             # np.ones((self.num_joints, 3)) 18,3
                &#39;joint_cam&#39;: joint_cam,             # 18,3 world2cam
                &#39;root_cam&#39;: root_cam,               # root_cam
                &#39;tot_bone_len&#39;: tot_bone_len,       # 骨架的总长度
                &#39;f&#39;: f,
                &#39;c&#39;: c
            &#125;)
    return items, labels
</code></pre>
]]></content>
      <tags>
        <tag>pose论文</tag>
      </tags>
  </entry>
  <entry>
    <title>mmlab</title>
    <url>/2023/07/14/mmlab/</url>
    <content><![CDATA[<p><a href="https://github.com/open-mmlab/mmpose">https://github.com/open-mmlab/mmpose</a></p>
<p><a href="https://github.com/TommyZihao/MMPose_Tutorials">https://github.com/TommyZihao/MMPose_Tutorials</a></p>
<p><a href="https://github.com/open-mmlab/OpenMMLabCourse">https://github.com/open-mmlab/OpenMMLabCourse</a></p>
<p>MMCV 核心组件分析（一）：整体概述 - OpenMMLab的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/336081587">https://zhuanlan.zhihu.com/p/336081587</a></p>
<h4 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h4><h6 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h6><p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p>
<pre><code>def a_new_decorator(a_func):
 
    def wrapTheFunction():
        print(&quot;I am doing some boring work before executing a_func()&quot;)
 
        a_func()
 
        print(&quot;I am doing some boring work after executing a_func()&quot;)
 
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;
    print(&quot;I am the function which needs some decoration to &quot;
          &quot;remove my foul smell&quot;)
          
a_function_requiring_decoration()
#outputs: I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()
</code></pre>
<h6 id="args-kwargs-python解释"><a href="#args-kwargs-python解释" class="headerlink" title="*args, **kwargs python解释"></a>*args, **kwargs python解释</h6><p>*args用于接收任意数量的位置参数，它将所有传递给函数的位置参数打包成一个元组（tuple）。例如：</p>
<pre><code>def my_function(*args):
    for arg in args:
        print(arg)

my_function(1, 2, 3)  # 输出 1 2 3
</code></pre>
<p>**kwargs用于接收任意数量的关键字参数，它将所有传递给函数的关键字参数打包成一个字典（dict）。例如：</p>
<pre><code>def my_function(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_function(name=&#39;Tom&#39;, age=20)  # 输出 name Tom  age 20
</code></pre>
<p><img src="/../images/mmlab/image-20230716001111023.png" alt="image-20230716001111023"></p>
<h1 id="不同组件"><a href="#不同组件" class="headerlink" title="不同组件"></a>不同组件</h1><p><strong>fileio、image、parallel、runner 和 utils 这几个非常通用的组件</strong></p>
<h1 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h1><ul>
<li>负责 OpenMMLab 中所有框架的训练过程调度，是一个基础但功能丰富的类</li>
<li>支持定制工作流以满足训练过程中各状态自由切换，目前支持训练和验证两个工作流</li>
<li>提供了 Epoch 和 Iter 为基础的迭代模式以满足不同场景，例如 MMDetection 默认采用 Epoch (配置文件中相关参数都是以  Epoch 为单位)，而 MMSegmentation 默认采用 Iter (配置文件中相关参数都是以 Iter 为单位)</li>
<li>配合各类 Hook，对外提供了灵活的扩展能力，注入不同类型的 Hook，就可以在训练过程中以一种优雅的方式实现扩展功能</li>
</ul>
<h2 id="Runner-分析"><a href="#Runner-分析" class="headerlink" title="Runner 分析"></a>Runner 分析</h2><ol>
<li>Runner 对象初始化</li>
<li>注册各类 Hook 到 Runner 中</li>
<li>调用 Runner 的 resume 或者 load_checkpoint 方法对权重进行加载</li>
<li>运行给定的工作流，此时才真正开启了工作流</li>
</ol>
<h3 id="Runner-初始化"><a href="#Runner-初始化" class="headerlink" title="Runner 初始化"></a>Runner 初始化</h3><p>考虑到 Epoch 和 Iter 模式有很多共有逻辑，为了复用，抽象出一个 BaseRunner。BaseRunner 初始化是一个常规初始化过程，其参数如下：</p>
<pre><code class="python">def __init__(self,
             model,
             batch_processor=None, # 已废弃
             optimizer=None,
             work_dir=None,
             logger=None,
             meta=None, # 提供了该参数，则会保存到 ckpt 中
             max_iters=None, # 这两个参数非常关键，如果没有给定，则内部自己计算
             max_epochs=None):
</code></pre>
<h3 id="注册-Hook"><a href="#注册-Hook" class="headerlink" title="注册 Hook"></a>注册 Hook</h3><p><code>register_training_hooks</code>，其作用是注册一些默认 Hook，如下所示：</p>
<pre><code class="python">def register_training_hooks(self,
                            lr_config, # lr相关
                            optimizer_config=None, # 优化器相关
                            checkpoint_config=None, # ckpt 保存相关
                            log_config=None, # 日志记录相关
                            momentum_config=None, # momentum 相关
                            timer_config=dict(type=&#39;IterTimerHook&#39;)) # 迭代时间统计
</code></pre>
<p>内部会自动解析这些配置，生成对应 Hook，并且注册到 Runner 中。</p>
<p><code>register_hook</code>，除了上面这些 Hook 外，其他所有 Hook，都是通过本方式注入，例如 <code>eval_hook</code>、<code>custom_hooks</code> 和 <code>DistSamplerSeedHook</code> 等等</p>
<p>其内部实现是将 Hook 类实例按照优先级插入 <code>_hooks</code> 列表中，运行时候会顺序调用。</p>
<pre><code class="python">def register_hook(self, hook, priority=&#39;NORMAL&#39;):
    # 获取优先级
    priority = get_priority(priority)
    hook.priority = priority
    # 基于优先级计算当前 hook 插入位置
    inserted = False
    for i in range(len(self._hooks) - 1, -1, -1):
        if priority &gt;= self._hooks[i].priority:
            self._hooks.insert(i + 1, hook)
            inserted = True
            break
    if not inserted:
        self._hooks.insert(0, hook)
</code></pre>
<h3 id="resume-或者-load-checkpoint"><a href="#resume-或者-load-checkpoint" class="headerlink" title="resume 或者 load_checkpoint"></a>resume 或者 load_checkpoint</h3><p>resume 方法用于训练过程中停止然后恢复训练时加载权重，而 load_checkpoint 仅仅是加载预训练权重而已，这个预训练权重可以来自官方，也可以来自自己训练后的权重，如果有 key 不匹配的参数则会自动跳过。由于这是常规操作，就不详细说明了。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>run 方法调用后才是真正开启工作流，并且由于 Epoch 和 Iter 模式流程不一样，所以在各自子类实现。</p>
<h4 id="EpochBasedRunner-run"><a href="#EpochBasedRunner-run" class="headerlink" title="EpochBasedRunner run"></a><strong>EpochBasedRunner run</strong></h4><pre><code class="python">def run(self, 
    data_loaders, # dataloader 列表
    workflow,  # 工作流列表，长度需要和 data_loaders 一致
    max_epochs=None, 
    **kwargs):
</code></pre>
<ul>
<li>假设只想运行训练工作流，则可以设置 workflow &#x3D; [(‘train’, 1)]，表示 data_loader 中的数据进行迭代训练</li>
<li>假设想运行训练和验证工作流，则可以设置 workflow &#x3D; [(‘train’, 3), (‘val’,1)]，表示先训练 3 个 epoch ，然后切换到 val 工作流，运行 1 个 epoch，然后循环，直到训练 epoch 次数达到指定值</li>
<li>工作流设置非常自由，例如你可以先验证再训练 workflow &#x3D; [(‘val’, 1), (‘train’,1)]</li>
</ul>
<p>需要注意的是：如果工作流有两个，那么 data_loaders 中也需要提供两个 dataloader。其核心逻辑如下：</p>
<pre><code class="python">def run(self, data_loaders, workflow, max_epochs=None, **kwargs):
    assert isinstance(data_loaders, list)
    assert mmcv.is_list_of(workflow, tuple)
    assert len(data_loaders) == len(workflow)

    # epoch 模式，需要自动计算出 _max_iters
    for i, flow in enumerate(workflow):
        mode, epochs = flow
        if mode == &#39;train&#39;:
            self._max_iters = self._max_epochs * len(data_loaders[i])
            break

    # 调用注册到 runner 中的所有 hook 的 before_run 方法，表示开启 run 前
    self.call_hook(&#39;before_run&#39;)

    # 如果没有达到退出条件，就一直运行工作流
    while self.epoch &lt; self._max_epochs:
        # 遍历工作流
        for i, flow in enumerate(workflow):
            # 模式，和当前工作流需要运行的 epoch 次数
            mode, epochs = flow
            epoch_runner = getattr(self, mode)
            for _ in range(epochs):
                if mode == &#39;train&#39; and self.epoch &gt;= self._max_epochs:
                    break
                # 开始一个 epoch 的迭代
                epoch_runner(data_loaders[i], **kwargs)
    time.sleep(1)  # wait for some hooks like loggers to finish

    # 调用注册到 runner 中的所有 hook 的 after_run 方法，表示结束 run 后
    self.call_hook(&#39;after_run&#39;)
</code></pre>
<p>可以看法 run 方法中定义的是通用工作流切换流程，真正完成一个 epoch 工作流是调用了工作流函数。目前支持 <code>train</code> 和 <code>val</code> 两个工作流，那么 <code>epoch_runner(data_loaders[i], **kwargs)</code> 调用的实际上是 <code>train</code> 或者 <code>val</code> 方法：</p>
<pre><code class="python"># train 和 val 方法逻辑非常相似
def train(self, data_loader, **kwargs):
    self.model.train()
    self.mode = &#39;train&#39;
    self.data_loader = data_loader
    self._max_iters = self._max_epochs * len(self.data_loader)
    self.call_hook(&#39;before_train_epoch&#39;)
    time.sleep(2)  # Prevent possible deadlock during epoch transition
    for i, data_batch in enumerate(self.data_loader):
        self._inner_iter = i
        self.call_hook(&#39;before_train_iter&#39;)
        self.run_iter(data_batch, train_mode=True)
        self.call_hook(&#39;after_train_iter&#39;)
        self._iter += 1
    self.call_hook(&#39;after_train_epoch&#39;)
    self._epoch += 1

@torch.no_grad()
def val(self, data_loader, **kwargs):
    self.model.eval()
    self.mode = &#39;val&#39;
    self.data_loader = data_loader
    self.call_hook(&#39;before_val_epoch&#39;)
    time.sleep(2)  # Prevent possible deadlock during epoch transition
    for i, data_batch in enumerate(self.data_loader):
        self._inner_iter = i
        self.call_hook(&#39;before_val_iter&#39;)
        self.run_iter(data_batch, train_mode=False)
        self.call_hook(&#39;after_val_iter&#39;)
    self.call_hook(&#39;after_val_epoch&#39;)
</code></pre>
<p>上述逻辑是遍历 data_loader，然后进行 batch 级别的迭代训练或者验证，比较容易理解。真正完成一个 batch 的训练或者验证是调用了 <code>self.run_iter</code> ：</p>
<pre><code class="python"># 简化逻辑
def run_iter(self, data_batch, train_mode, **kwargs):
    # 调用 model 自身的 train_step 或者 val_step 方法
    if train_mode:
        outputs = self.model.train_step(data_batch, self.optimizer,
                                        **kwargs)
    else:
        outputs = self.model.val_step(data_batch, self.optimizer, **kwargs)

    if &#39;log_vars&#39; in outputs:
        self.log_buffer.update(outputs[&#39;log_vars&#39;], outputs[&#39;num_samples&#39;])

    self.outputs = outputs
</code></pre>
<h4 id="IterBasedRunner-run"><a href="#IterBasedRunner-run" class="headerlink" title="IterBasedRunner run"></a><strong>IterBasedRunner run</strong></h4><p>由于 <code>IterBasedRunner</code> 模式没有 epoch 的概念，故 <code>IterBasedRunner</code> 的 run 方法有些许改动</p>
<ul>
<li>工作流终止条件不再是 epoch，而是 iter</li>
<li>Hook 的生命周期方法也不涉及 epoch，全部是 iter 相关方法</li>
<li>虽然本类中不需要 epoch 参数，但是 epoch 参数在很多场景比较有用，故还是需要通过 <code>IterLoader</code> 得到</li>
</ul>
<pre><code class="python">class IterLoader:

    def __init__(self, dataloader):
        self._dataloader = dataloader
        self.iter_loader = iter(self._dataloader)
        self._epoch = 0

    @property
    def epoch(self):
        return self._epoch

    def __next__(self):
        try:
            data = next(self.iter_loader)
        except StopIteration:
            # 迭代完一次，就表示一个 epoch 完成
            self._epoch += 1
            # 保证分布式场景下，一个 epoch 内部各个卡的随机是确定的
            if hasattr(self._dataloader.sampler, &#39;set_epoch&#39;):
                self._dataloader.sampler.set_epoch(self._epoch)
            # 开启下一次迭代
            self.iter_loader = iter(self._dataloader)
            data = next(self.iter_loader)

        return data

    def __len__(self):
        return len(self._dataloader)
</code></pre>
<p>假设数据长度是 1024，batch&#x3D;4，那么 dataloader 长度是 1024&#x2F;4&#x3D;256, 也就是一个 epoch 是 256  次迭代，在 Iter 训练模式下，计划训练 100000 个迭代，那么实际上运行了 100000&#x2F;&#x2F;256&#x3D;39 个 epoch。</p>
<h1 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h1><pre><code class="text">拦截软件模块间的函数调用、消息传递、事件传递来修改或扩展操作系统、应用程序或其他软件组件的行为的各种技术。处理被拦截的函数调用、事件、消息的代码，被称为钩子（hook）
</code></pre>
<p>在我们熟知的 pytorch 中某个 tensor 或者 module 都有 <code>register_hook(hook_fn)</code> 函数，通过注册 hook，可以拦截和修改某些中间变量的值。</p>
<h2 id="python实现hook机制"><a href="#python实现hook机制" class="headerlink" title="python实现hook机制"></a>python实现hook机制</h2><p>传入一个函数即可，如下是一个简单的 hook，该 hook 的功能是打印内部变量</p>
<pre><code>def hook(d):
   print(d)

def add(a,b,c,hook_fn=None)
   sum1=a+b
   if hook_fn is not None:
       hook_fn(sum1)
    return sum1+c

# 调用
add(1,2,3,hook)
</code></pre>
<h2 id="PyTorch实现hook机制"><a href="#PyTorch实现hook机制" class="headerlink" title="PyTorch实现hook机制"></a>PyTorch实现hook机制</h2><pre><code>import torch
from torch import nn
from mmcv.cnn import constant_init

# hook 函数，其三个参数不能修改(参数名随意)，本质上是 PyTorch 内部回调函数

# module 本身对象
# input 该 module forward 前输入
# output 该 module forward 后输出
def forward_hook_fn(module, input, output):
    print(&#39;weight&#39;, module.weight.data)
    print(&#39;bias&#39;, module.bias.data)
    print(&#39;input&#39;, input)
    print(&#39;output&#39;, output)

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.fc = nn.Linear(3, 1)
        self.fc.register_forward_hook(forward_hook_fn)
        constant_init(self.fc, 1)

    def forward(self, x):
        o = self.fc(x)
        return o
</code></pre>
<p>运行输出：</p>
<pre><code>if __name__ == &#39;__main__&#39;:
    model = Model()
    x = torch.Tensor([[0.0, 1.0, 2.0]])
    y = model(x)

# 输出
weight：tensor([[1., 1., 1.]])
bias: tensor([0.])
input: (tensor([[0., 1., 2.]]),)
output:tensor([[3.]], grad_fn=&lt;AddmmBackward&gt;)
</code></pre>
<h2 id="MMCV-内置的常用-Hook"><a href="#MMCV-内置的常用-Hook" class="headerlink" title="MMCV 内置的常用 Hook"></a>MMCV 内置的常用 Hook</h2><h3 id="Hook-调用机制"><a href="#Hook-调用机制" class="headerlink" title="Hook 调用机制"></a>Hook 调用机制</h3><p>前面说过 Hook 是可以注册进 Runner 中，不同类型的 Hook 实现了不同的生命周期方法从而完成不同的功能，以一个典型的训练过程为例，EpochBasedRunner(以 epoch 为单位) 中生命周期方法如下所示：</p>
<pre><code># 开始运行时调用
before_run()

while self.epoch &lt; self._max_epochs:

    # 开始 epoch 迭代前调用
    before_train_epoch()

    for i, data_batch in enumerate(self.data_loader):
        # 开始 iter 迭代前调用
        before_train_iter()

        self.model.train_step()

        # 经过一次迭代后调用
        after_train_iter()

    # 经过一个 epoch 迭代后调用
    after_train_epoch()

# 运行完成前调用
after_run()
</code></pre>
<p>只要注册的 Hook 对象实现了某一个或者某几个生命周期方法，当 Runner 运行到预定义的位点时候就会调用对应的 Hook 中方法。</p>
<h3 id="Hook-分类和用法"><a href="#Hook-分类和用法" class="headerlink" title="Hook 分类和用法"></a>Hook 分类和用法</h3><p><img src="/../images/mmlab/image-20230724223943012.png" alt="image-20230724223943012"></p>
<p>目前 MMCV 中实现的 Hook 如上图所示，后续可能会新增。之所以划分为默认 Hook 和定制 Hook，原因是默认 Hook不需要用户自行注册，用户通过 <code>hook 名_config</code> 配置对应参数即可，例如 <code>checkpoint_config</code> 如果你不打开源码阅读，你可能不知道模型权重保存功能是通过 Hook 实现的，而对于定制类 Hook，则需要用户手动注册或者通过配置方式注册进去，通过下面的源码解读大家可以很容易分辨两者的区别。</p>
<h4 id="默认HOOK"><a href="#默认HOOK" class="headerlink" title="默认HOOK"></a>默认HOOK</h4><p>对于默认 Hook，在 MMDetection 框架训练过程中，其注册代码为：</p>
<pre><code>runner.register_training_hooks(cfg.lr_config, optimizer_config,
                               cfg.checkpoint_config, cfg.log_config,
                               cfg.get(&#39;momentum_config&#39;, None))
</code></pre>
<p><code>register_training_hooks</code> 函数的接收参数其实是字典参数，Runner 内部会根据配置自动生成对应的 Hook 实例，典型的 <code>lr_config</code> 为：</p>
<pre><code>lr_config = dict(
    policy=&#39;step&#39;,
    warmup=&#39;linear&#39;,
    warmup_iters=500,
    warmup_ratio=0.001,
    step=[16, 22])
</code></pre>
<p>由于 <code>lr_config</code> 没有显示的调用 Hook 类，故对于用户而言其实不知道是采用 Hook 机制实现的。</p>
<h4 id="定制HOOK"><a href="#定制HOOK" class="headerlink" title="定制HOOK"></a>定制HOOK</h4><p>对于定制类 Hook，其注册源码如下：</p>
<pre><code># user-defined hooks
if cfg.get(&#39;custom_hooks&#39;, None):
    custom_hooks = cfg.custom_hooks
    for hook_cfg in cfg.custom_hooks:
        hook_cfg = hook_cfg.copy()
        priority = hook_cfg.pop(&#39;priority&#39;, &#39;NORMAL&#39;)
        # 通过配置实例化定制 hook
        hook = build_from_cfg(hook_cfg, HOOKS)
        # 注册
        runner.register_hook(hook, priority=priority)
</code></pre>
<p>以 MMDetection 中实现的 EMAHook 为例，其 .py 配置文件应该写成：</p>
<pre><code>custom_hooks=[dict(type=&#39;EMAHook&#39;)]
</code></pre>
<p>如果想注册多个 Hook，则追加 list 即可，你也可以对每个 Hook 增加调用优先级。</p>
<h4 id="常用-Hook-类简析"><a href="#常用-Hook-类简析" class="headerlink" title="常用 Hook 类简析"></a>常用 Hook 类简析</h4><h5 id="CheckpointHook"><a href="#CheckpointHook" class="headerlink" title="CheckpointHook"></a><strong>CheckpointHook</strong></h5><p>CheckpointHook 主要是对模型参数进行保存，如果是分布式多卡训练，则仅仅会在 master 进程保存。同时可以通过 <code>max_keep_ckpts</code> 参数设置最多保存多少个权重文件，早期额外的权重会自动删除。</p>
<p>如果以 epoch 为单位进行保存，则该 Hook 实现 <code>after_train_epoch</code> 方法即可，否则仅实现 <code>after_train_iter</code> 方法即可。</p>
<p>考虑到分布式训练过程，如果有必要(例如分布式训练中没有使用同步 BN，而是普通 BN)，则可以通过设置参数 <code>sync_buffer</code> 为 True，在保存权重前，会对模型 buffers(典型的例如 BN 的全局均值和方差参数) 进行跨卡同步，让每张卡的 buffers 参数都相同，此时在 master 进程保存权重和 buffer，才是合理的。</p>
<h5 id="LrUpdaterHook"><a href="#LrUpdaterHook" class="headerlink" title="LrUpdaterHook"></a><strong>LrUpdaterHook</strong></h5><p>LrUpdaterHook 用于学习率调度，为了统一代码风格以及方便扩展，MMDetection 等训练框架并没有直接继承 PyTorch 提供的学习率调度器，而是通过 LrUpdaterHook 实现。</p>
<p>如果是以 iter 为单位，则仅仅需要在 <code>before_train_iter</code> 方法中实现学习率调度功能，如果是以 epoch 为单位，则还需要在 <code>before_train_epoch</code> 中实现相关操作。简单来说要实时改变学习率，核心如下：</p>
<pre><code>def _set_lr(self, runner, lr_groups):
    if isinstance(runner.optimizer, dict):
        for k, optim in runner.optimizer.items():
            for param_group, lr in zip(optim.param_groups, lr_groups[k]):
                # 对不同的参数组设置对应的学习率即可
                param_group[&#39;lr&#39;] = lr
    else:
        for param_group, lr in zip(runner.optimizer.param_groups,
                                   lr_groups):
            param_group[&#39;lr&#39;] = lr
</code></pre>
<p>然后在优化器进行参数更新时候会自动读取参数组的 <code>lr</code> 参数，从而实现梯度下降参数更新。</p>
<p>LrUpdaterHook 还提供了 warmup 功能，并且支持 <code>constant, linear, exp</code> 三种方式。为了方便使用，MMCV 中还提供了非常多的常用学习率调度策略，如下所示：</p>
<ul>
<li>FixedLrUpdaterHook 固定学习率</li>
<li>StepLrUpdaterHook 单步和多步阶学习率调度</li>
<li>ExpLrUpdaterHook 指数学习率</li>
<li>PolyLrUpdaterHook 多项式学习率</li>
<li>InvLrUpdaterHook 和指数学习率类似的调度策略</li>
<li>CosineAnnealingLrUpdaterHook 余弦退火学习率</li>
<li>CosineRestartLrUpdaterHook 带重启的余弦退火学习率</li>
<li>CyclicLrUpdaterHook 循环学习率</li>
</ul>
<h5 id="OptimizerHook"><a href="#OptimizerHook" class="headerlink" title="OptimizerHook"></a><strong>OptimizerHook</strong></h5><p>OptimizerHook 功能比较简单：梯度反向传播加上参数更新，如果指定了梯度裁剪参数，则可以进行梯度裁剪。同时在该 Hook 基础上还实现了 Fp16OptimizerHook 进行混合自动训练。关于混合精度训练原理和实现，可以参考 <code>pytorch 源码解读系列文章</code>。</p>
<h5 id="ClosureHook"><a href="#ClosureHook" class="headerlink" title="ClosureHook"></a><strong>ClosureHook</strong></h5><p>ClosureHook 比较特殊，他的主要功能是提供最简洁的函数注册。可以想象一个场景：在训练过程中，想知道目前的迭代次数，在目前框架体系下最优雅的实现方式是：用户自己写一个获取 lr 的 Hook 类，然后在配置文件中通过 <code>custom_hooks</code> 注册进去，该类的代码如下所示：</p>
<pre><code>@HOOKS.register_module()
class GetIterHook(Hook):
    def after_train_iter(self, runner):
        print(runner.iter)
</code></pre>
<p>可以发现你需要做如下事情：</p>
<ol>
<li>写一个 GetIterHook 类，继承自 Hook</li>
<li>在类上方加上 @HOOKS.register_module()</li>
<li>在对应的 <code>__init__.py</code> 文件中进行导入</li>
<li>将该 Hook 注册到 Runner 中</li>
</ol>
<p>需要完成三个步骤，但是实际上我只是想 <code>print</code> 而已，比较繁琐，而 ClosureHook 的作用就是为了简化流程。你现在要做的事情如下所示：</p>
<pre><code>def getiter(runner):
    print(runner.iter)
</code></pre>
<ol>
<li>定义如上函数</li>
<li>作为参数输入给 ClosureHook，并且实例化 <code>ClosureHook(&#39;after_train_iter&#39;, getiter)</code></li>
<li>将该 Hook 注册到 Runner 中</li>
</ol>
<p>ClosureHook 主要用于一些非常简单的 Hook，但是又不想重新定义一个类来实现，此时就可以通过定义函数，然后传递给 ClosureHook 即可。</p>
<p>其余一些默认 Hook 比较简单，功能一目了然，本文就不进行详细说明了。</p>
<h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><h2 id="Registry-功能"><a href="#Registry-功能" class="headerlink" title="Registry 功能"></a>Registry 功能</h2><p>在 OpenMMLab 中，Registry 类可以提供一种完全相似的对外装饰函数来管理构建不同的组件，例如 backbones、head 和  necks 等等，Registry 类内部其实维护的是一个全局 key-value 对。通过 Registry  类，用户可以通过字符串方式实例化任何想要的模块。例如在 Faster R-CNN 的 backbone 模块实例化时，可以采用如下配置：</p>
<pre><code>backbone=dict(
    type=&#39;ResNet&#39;, # 待实例化的类名
    depth=50, # 后面的都是对于的类初始化参数
    num_stages=4,
    out_indices=(0, 1, 2, 3),
    frozen_stages=1,
    norm_cfg=dict(type=&#39;BN&#39;, requires_grad=True),
    norm_eval=True,
    style=&#39;pytorch&#39;),
</code></pre>
<h2 id="Registry-用法"><a href="#Registry-用法" class="headerlink" title="Registry 用法"></a>Registry 用法</h2><pre><code># 0. 先构建一个全局的 CATS 注册器类
CATS = mmcv.Registry(&#39;cat&#39;)

# 通过装饰器方式作用在想要加入注册器的具体类中
#===============================================================
# 1. 不需要传入任何参数，此时默认实例化的配置字符串是 str (类名)
@CATS.register_module()
class BritishShorthair:
    pass
# 类实例化
CATS.get(&#39;BritishShorthair&#39;)(**args)

#==============================================================
# 2.传入指定 str，实例化时候只需要传入对应相同 str 即可
@CATS.register_module(name=&#39;Siamese&#39;)
class SiameseCat:
    pass
# 类实例化
CATS.get(&#39;Siamese&#39;)(**args)

#===============================================================
# 3.如果出现同名 Registry Key，可以选择报错或者强制覆盖
# 如果指定了 force=True，那么不会报错
# 此时 Registry 的 Key 中，Siamese2Cat 类会覆盖 SiameseCat 类
# 否则会报错
@CATS.register_module(name=&#39;Siamese&#39;,force=True)
class Siamese2Cat:
    pass
# 类实例化
CATS.get(&#39;Siamese&#39;)(**args)

#==============================================================
# 4. 可以直接注册类
class Munchkin:
    pass
CATS.register_module(Munchkin)

# 类实例化
CATS.get(&#39;Munchkin&#39;)(**args)
</code></pre>
<h2 id="Registry-最简实现"><a href="#Registry-最简实现" class="headerlink" title="Registry 最简实现"></a>Registry 最简实现</h2><p><strong>上述功能实现的核心是 python 中装饰器用法</strong></p>
<h3 id="最简实现"><a href="#最简实现" class="headerlink" title="最简实现"></a><strong>最简实现</strong></h3><pre><code># 方便起见，此处并未使用类方式构建，而是直接采用全局变量

_module_dict = dict()

# 定义装饰器函数
def register_module(name):
    def _register(cls):
        _module_dict[name] = cls
        return cls

    return _register

# 装饰器用法
@register_module(&#39;one_class&#39;)
class OneTest(object):
    pass

@register_module(&#39;two_class&#39;)
class TwoTest(object):
    pass
</code></pre>
<p>进行简单测试：</p>
<pre><code>if __name__ == &#39;__main__&#39;:
    # 通过注册类名实现自动实例化功能
    one_test = _module_dict[&#39;one_class&#39;]()
    print(one_test)

# 输出
&lt;__main__.OneTest object at 0x7f1d7c5acee0&gt;
</code></pre>
<p>可以发现只要将所定义的简单装饰器函数作用到类名上，然后内部采用 <code>_module_dict</code> 保存信息即可</p>
<h3 id="实现无需传入参数，自动根据类名初始化类"><a href="#实现无需传入参数，自动根据类名初始化类" class="headerlink" title="实现无需传入参数，自动根据类名初始化类"></a><strong>实现无需传入参数，自动根据类名初始化类</strong></h3><pre><code>_module_dict = dict()

def register_module(module_name=None):
    def _register(cls):
        name = module_name
        # 如果 module_name 没有给，则自动获取
        if module_name is None:
            name = cls.__name__
        _module_dict[name] = cls
        return cls

    return _register

@register_module(&#39;one_class&#39;)
class OneTest(object):
    pass

@register_module()
class TwoTest(object):
    pass
</code></pre>
<p>进行简单测试：</p>
<pre><code>if __name__ == &#39;__main__&#39;:
    one_test = _module_dict[&#39;one_class&#39;]
    # 方便起见，此处仅仅打印了类对象，而没有实例化。如果要实例化，只需要 one_test() 即可
    print(one_test)
    two_test = _module_dict[&#39;TwoTest&#39;]
    print(two_test)

# 输出
&lt;class &#39;__main__.OneTest &#39;&gt;
&lt;class &#39;__main__.TwoTest&#39;&gt;
</code></pre>
<h3 id="实现重名注册强制报错功能"><a href="#实现重名注册强制报错功能" class="headerlink" title="实现重名注册强制报错功能"></a><strong>实现重名注册强制报错功能</strong></h3><pre><code>def register_module(module_name=None):
    def _register(cls):
        name = module_name
        if module_name is None:
            name = cls.__name__

        # 如果重名注册，则强制报错
        if name in _module_dict:
            raise KeyError(f&#39;&#123;module_name&#125; is already registered &#39;
                           f&#39;in &#123;name&#125;&#39;)
        _module_dict[name] = cls
        return cls

    return _register
</code></pre>
<h3 id="实现重名注册强制报错功能-1"><a href="#实现重名注册强制报错功能-1" class="headerlink" title="实现重名注册强制报错功能"></a><strong>实现重名注册强制报错功能</strong></h3><p>新增一个 force 参数即可</p>
<pre><code>def register_module(module_name=None,force=False):
    def _register(cls):
        name = module_name
        if module_name is None:
            name = cls.__name__

        # 如果重名注册，则强制报错
        if not force and name in _module_dict:
            raise KeyError(f&#39;&#123;module_name&#125; is already registered &#39;
                           f&#39;in &#123;name&#125;&#39;)
        _module_dict[name] = cls
        return cls

    return _register
</code></pre>
<p>测试：</p>
<pre><code>@register_module(&#39;one_class&#39;)
class OneTest(object):
    pass

@register_module(&#39;one_class&#39;,True)
class TwoTest(object):
    pass

if __name__ == &#39;__main__&#39;:
    one_test = _module_dict[&#39;one_class&#39;]
    print(one_test)

# 输出
&lt;class &#39;__main__.TwoTest&#39;&gt;
</code></pre>
<h3 id="实现直接注册类功能"><a href="#实现直接注册类功能" class="headerlink" title="实现直接注册类功能"></a><strong>实现直接注册类功能</strong></h3><p>实现直接注册类的功能，只需要 <code>_module_dict[&#39;name&#39;] = module_class</code> 即可。</p>
<p>上述内容基本讲解了 Registry 里面所有功能。实际上采用类的方式来管理会更加优雅方便，也就是 MMCV 中的实现方式。</p>
<h3 id="Registry-类实现"><a href="#Registry-类实现" class="headerlink" title="Registry 类实现"></a>Registry 类实现</h3><p>基于上面的理解，此时再来看 MMCV 实现就会非常简单了，核心逻辑如下：</p>
<pre><code>class Registry:
    def __init__(self, name):
        # 可实现注册类细分功能
        self._name = name 
        # 内部核心内容，维护所有的已经注册好的 class
        self._module_dict = dict()

    def _register_module(self, module_class, module_name=None, force=False):
        if not inspect.isclass(module_class):
            raise TypeError(&#39;module must be a class, &#39;
                            f&#39;but got &#123;type(module_class)&#125;&#39;)

        if module_name is None:
            module_name = module_class.__name__
        if not force and module_name in self._module_dict:
            raise KeyError(f&#39;&#123;module_name&#125; is already registered &#39;
                           f&#39;in &#123;self.name&#125;&#39;)
        # 最核心代码
        self._module_dict[module_name] = module_class

    # 装饰器函数
    def register_module(self, name=None, force=False, module=None):
        if module is not None:
            # 如果已经是 module，那就知道 增加到字典中即可
            self._register_module(
                module_class=module, module_name=name, force=force)
            return module

        # 最标准用法
        # use it as a decorator: @x.register_module()
        def _register(cls):
            self._register_module(
                module_class=cls, module_name=name, force=force)
            return cls
        return _register
</code></pre>
<p>在 MMCV 中所有的类实例化都是通过 <code>build_from_cfg</code> 函数实现，做的事情非常简单，就是给定 <code>module_name</code>，然后从 <code>self._module_dict</code> 提取即可。</p>
<pre><code>def build_from_cfg(cfg, registry, default_args=None):
    args = cfg.copy()

    if default_args is not None:
        for name, value in default_args.items():
            args.setdefault(name, value)

    obj_type = args.pop(&#39;type&#39;) # 注册 str 类名
    if is_str(obj_type):
        # 相当于 self._module_dict[obj_type]
        obj_cls = registry.get(obj_type)
        if obj_cls is None:
            raise KeyError(
                f&#39;&#123;obj_type&#125; is not in the &#123;registry.name&#125; registry&#39;)

    # 如果已经实例化了，那就直接返回
    elif inspect.isclass(obj_type):
        obj_cls = obj_type
    else:
        raise TypeError(
            f&#39;type must be a str or valid type, but got &#123;type(obj_type)&#125;&#39;)

    # 最终初始化对于类，并且返回，就完成了一个类的实例化过程
    return obj_cls(**args)
</code></pre>
<p>一个完整的使用例子如下：</p>
<pre><code>CONVERTERS = Registry(&#39;converter&#39;)

@CONVERTERS.register_module()
class Converter1(object):
    def __init__(self, a, b):
        self.a = a
        self.b = b

converter_cfg = dict(type=&#39;Converter1&#39;, a=a_value, b=b_value)
converter = build_from_cfg(converter_cfg,CONVERTERS)
</code></pre>
<h1 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h1><p>py、json、ymal 和 yml配置文件解析功能。</p>
<p>mmcv\utils\config.py</p>
<h6 id="Config-fromfile-函数"><a href="#Config-fromfile-函数" class="headerlink" title="Config.fromfile 函数"></a>Config.fromfile 函数</h6><p>参数：filename、use_predefined_variables、import_custom_modules</p>
<p>import_custom_modules 默认是 True</p>
<h6 id="cfg-merge-from-dict函数"><a href="#cfg-merge-from-dict函数" class="headerlink" title="cfg.merge_from_dict函数"></a>cfg.merge_from_dict函数</h6><p>接口可以实现对字典内容进行合并</p>
<h6 id="通过-dict-生成-config"><a href="#通过-dict-生成-config" class="headerlink" title="通过 dict 生成 config"></a>通过 dict 生成 config</h6><pre><code>cfg = Config(dict(a=1, b=dict(b1=[0, 1])))

# 可以通过 .属性方式访问，比较方便
cfg.b.b1 # [0, 1]
</code></pre>
<h6 id="通过配置文件生成config"><a href="#通过配置文件生成config" class="headerlink" title="通过配置文件生成config"></a>通过配置文件生成config</h6><p>该功能最为常用，配置文件可以是 py、yaml、yml 和 json 格式。</p>
<pre><code># Copyright (c) OpenMMLab. All rights reserved.
# &#39;tests/data/config/a.py&#39; 里面的内容
item1 = [1, 2]
item2 = &#123;&#39;a&#39;: 0&#125;
item3 = True
item4 = &#39;test&#39;
</code></pre>
<pre><code>cfg = Config.fromfile(&#39;tests/data/config/a.py&#39;)

cfg.filename
cfg.item4 # &#39;test&#39;
cfg # 打印 config path，和字典内容...
&gt;&gt;&gt; cfg = Config.fromfile(&#39;tests/data/config/a.py&#39;)
&gt;&gt;&gt; cfg.filename
&quot;/home/kchen/projects/mmcv/tests/data/config/a.py&quot;
&gt;&gt;&gt; cfg.item4
&#39;test&#39;
&gt;&gt;&gt; cfg
&quot;Config [path: /home/kchen/projects/mmcv/tests/data/config/a.py]: &quot;
&quot;&#123;&#39;item1&#39;: [1, 2], &#39;item2&#39;: &#123;&#39;a&#39;: 0&#125;, &#39;item3&#39;: True, &#39;item4&#39;: &#39;test&#39;&#125;&quot;
</code></pre>
<h6 id="自动替换预定义变量"><a href="#自动替换预定义变量" class="headerlink" title="自动替换预定义变量"></a>自动替换预定义变量</h6><p>tests\data\config\h.py</p>
<p>h.py内容为</p>
<pre><code># Copyright (c) OpenMMLab. All rights reserved.
item1 = &#39;&#123;&#123;fileBasename&#125;&#125;&#39;
item2 = &#39;&#123;&#123; fileDirname&#125;&#125;&#39;
item3 = &#39;abc_&#123;&#123; fileBasenameNoExtension &#125;&#125;&#39;
</code></pre>
<p>上面的fileBasename,fileDirname,fileBasenameNoExtension都是预定义的变量，那变量的定义是参考vscode里面设计的</p>
<p><a href="https://code.visualstudio.com/docs/editor/variables-reference">https://code.visualstudio.com/docs/editor/variables-reference</a></p>
<p>使用过程：</p>
<pre><code># cfg_file 文件名是 h.py
cfg = Config.fromfile(cfg_file, use_predefined_variables=True)
print(cfg.pretty_text)

# 输出
item1 = &#39;h.py&#39;
item2 = &#39;config 文件路径&#39;
item3 = &#39;abc_h&#39;
</code></pre>
<p>该参数主要用途是自动替换 Config 类中已经预定义好的变量模板为真实值，在某些场合有用</p>
<h6 id="导入自定义模块"><a href="#导入自定义模块" class="headerlink" title="导入自定义模块"></a>导入自定义模块</h6><p>Config.fromfile 函数除了有 filename 和 use_predefined_variables 参数外，还有 import_custom_modules，默认是 True，即当 cfg中存在 custom_imports 键时候会对里面的内容进行自动导入，其输入格式要么是 str 要么是 list[str]，表示待导入的模块路径，一个典型用法是：假设你在 mmdet 中新增了自定义模型 MobileNet ，你需要在 mmdet&#x2F;models&#x2F;backbones&#x2F;<strong>init</strong>.py 里面加入如下代码，否则在调用时候会提示该模块没有被注册进去：</p>
<pre><code>from .mobilenet import MobileNet
</code></pre>
<p>但是上述做法在某些场景下会比较麻烦。例如该模块处于非常深的层级，那么就需要逐层修改 <code>__init__.py</code>，有了本参数，便可以采用如下做法优雅避免：</p>
<pre><code># .py 文件里面存储如下内容
custom_imports = dict(
    imports=[&#39;mmdet.models.backbones.mobilenet&#39;],
    allow_failed_imports=False)

# 自动导入 mmdet.models.backbones.mobilenet
Config.fromfile(cfg_file, import_custom_modules=True)
</code></pre>
<h6 id="合并多个配置文件"><a href="#合并多个配置文件" class="headerlink" title="合并多个配置文件"></a>合并多个配置文件</h6><ul>
<li><p>base 文件的 key 是不允许改的，必须是 <code>_base_</code> ，否则程序不知道哪个字段才是 base</p>
</li>
<li><p>多个 base 以 list 方式并行构建模式下，不允许多个 base 文件中有相同字段，程序会报 Duplicate Key Error，因为此时不知道以哪个配置为主</p>
</li>
<li><p>从单个base文件中合并:</p>
<p>base.p与d.py在同一文件夹下！</p>
<p>. 表示当前目录，&#x2F; 表示目录的分隔符，.. 表示上一级目录，</p>
<pre><code># base.py 内容

item1 = [1, 2]
item2 = &#123;&#39;a&#39;: 0&#125;
item3 = True
item4 = &#39;test&#39;

# d.py 内容
_base_ = &#39;./base.py&#39;
item1 = [2, 3]
item2 = &#123;&#39;a&#39;: 1&#125;
item3 = False
item4 = &#39;test_base&#39;

# 用法
cfg = Config.fromfile(&#39;d.py&#39;)

# 输出
item1 = [2, 3]
item2 = dict(a=1)
item3 = False
item4 = &#39;test_base&#39;
</code></pre>
</li>
<li><p>从多个base文件中合并Config：</p>
<p>用户只需要在非 base 配置文件中将类似 <em>base</em> &#x3D; ‘.&#x2F;base.py’改成 <em>base</em> &#x3D; [‘.&#x2F;base.py’,…] 即可。</p>
</li>
<li><p>合并字典到配置</p>
<pre><code># Copyright (c) OpenMMLab. All rights reserved.
item1 = [1, 2]
item2 = &#123;&#39;a&#39;: 0&#125;
item3 = True
item4 = &#39;test&#39;
</code></pre>
<pre><code>cfg_file = osp.join(data_path, &#39;config/a.py&#39;)
cfg = Config.fromfile(cfg_file)
input_options = &#123;&#39;item2.a&#39;: 1, &#39;item2.b&#39;: 0.1, &#39;item3&#39;: False&#125;
cfg.merge_from_dict(input_options)

# 原始 a.py 内容为：
item1 = [1, 2]
item2 = &#123;&#39;a&#39;: 0&#125;
item3 = True
item4 = &#39;test&#39;

# 进行合并后, cfg 内容
item1 = [1, 2]
item2 = dict(a=1, b=0.1)
item3 = False
item4 = &#39;test&#39;
</code></pre>
</li>
<li><h6 id="allow-list-keys-模式合并"><a href="#allow-list-keys-模式合并" class="headerlink" title="allow_list_keys 模式合并"></a>allow_list_keys 模式合并</h6><p>假设某个配置文件中内容为：item &#x3D; [dict(a&#x3D;0), dict(b&#x3D;0, c&#x3D;0)]可以通过如下方式修改 list 内容：</p>
<pre><code class="python">input_options = &#123;&#39;item.0.a&#39;: 1, &#39;item.1.b&#39;: 1&#125;
cfg.merge_from_dict(input_options, allow_list_keys=True)

# 输出
item = [dict(a=1), dict(b=1, c=0)]
</code></pre>
</li>
</ul>
<p>​		如果 input_options 内部索引越界或者 allow_list_keys&#x3D;False (默认是 True)，则会报错。</p>
<h6 id="允许删掉特定内容"><a href="#允许删掉特定内容" class="headerlink" title="允许删掉特定内容"></a>允许删掉特定内容</h6><p>该功能也比较常用，思考如下场景：在 RetinaNet 算法中，其采用的 bbox 回归 loss 配置如下：</p>
<pre><code class="python">loss_bbox=dict(type=&#39;L1Loss&#39;, loss_weight=1.0，其他参数)
</code></pre>
<p>上述配置是在 base 文件中，但是在 FASF 算法中采用的是 IOULoss，现在要做的事情是在 FASF 配置中自动覆盖掉 base 配置中的 L1Loss，可以采用如下做法：</p>
<pre><code class="python">loss_bbox=dict(
    _delete_=True,
    type=&#39;IoULoss&#39;,
    eps=1e-6,
    loss_weight=1.0,
    reduction=&#39;none&#39;)
</code></pre>
<p>如果没有 <em>delete</em>&#x3D;True 参数，则两个配置会自动合并，L1Loss 中的其他参数始终会保留，无法删除，这肯定是不正确的( IoULoss 中不需要 L1Loss 的初始化参数)，现在通过引入 <em>delete</em> 保留字则可以实现忽略 base 相关配置，直接采用新配置文件字段功能。</p>
<h6 id="pretty-text-和-dump"><a href="#pretty-text-和-dump" class="headerlink" title="pretty_text 和 dump"></a>pretty_text 和 dump</h6><p>pretty_text 函数可以将字典内容按照 PEP8 格式打印，输出结构清晰，非常好看，如下所示：</p>
<pre><code># 直接打印字典内容
print(cfg._cfg_dict)
# 输出
&#123;&#39;item1&#39;: [1, 2], &#39;item2&#39;: &#123;&#39;a&#39;: 1, &#39;b&#39;: 0.1&#125;, &#39;item3&#39;: False, &#39;item4&#39;: &#39;test&#39;&#125;

# pretty 打印字典内容
print(cfg.pretty_text)
# 输出
item1 = [1, 2]
item2 = dict(a=1, b=0.1)
item3 = False
item4 = &#39;test&#39;
</code></pre>
<p>上述功能是解决第三方库 yapf 实现。而 dump 功能就是将 cfg 内容保存，当想查看实验配置是否正确、查看实验记录以及复现以前实验结果时候非常有用。</p>
<h2 id="config源码解析"><a href="#config源码解析" class="headerlink" title="config源码解析"></a>config源码解析</h2><h3 id="字典对象实现属性访问"><a href="#字典对象实现属性访问" class="headerlink" title="字典对象实现属性访问"></a>字典对象实现属性访问</h3><p>借助第三方库 <code>addict</code> 实现，具体用法是：</p>
<pre><code>from addict import Dict

# 将原始 dict 用 Dict 对象包裹，就可以了
a = Dict(dict(b=1, c=dict(d=2)))
print(a.c.d)
</code></pre>
<p>在 Config 类中也是直接继承至 Dict</p>
<pre><code>class ConfigDict(Dict):
    def __getattr__(self, name):
        try:
            value = super(ConfigDict, self).__getattr__(name)
        except KeyError:
            ex = AttributeError(f&quot;&#39;&#123;self.__class__.__name__&#125;&#39; object has no &quot;
                                f&quot;attribute &#39;&#123;name&#125;&#39;&quot;)
        except Exception as e:
            ex = e
        else:
            return value
        raise ex
</code></pre>
<p>那么 Dict 内部是如何实现的呢？其最简实现如下：</p>
<pre><code>class Dict(dict):
    def __init__(self, *args):
        super().__init__()
        for arg in args:
            for key, val in arg.items():
                # 对字典对象进行属性设置，并进行迭代
                self[key] = self._hook(val)

    def _hook(self, item):
        if isinstance(item, dict):
            return Dict(item)  # 递归调用
        return item

    # 在.a和[&#39;a&#39;]时候自动调用
    def __getattr__(self, item):
        return self[item]
</code></pre>
<p>核心实现原理是：对于输入的字典，进行深度遍历，并且通过 self[key] 进行赋值，在进行属性访问时候会自动调用 <code>__getattr__</code> 方法返回。</p>
<h3 id="字典对象-pretty-输出"><a href="#字典对象-pretty-输出" class="headerlink" title="字典对象 pretty 输出"></a>字典对象 pretty 输出</h3><p>很多开发者都会碰到：<strong>当字典对象层级非常深，直接 print 打印时候会非常难看的问题</strong>，一种比较通用的做法就是自己不断递归字典对象，然后对不同的层级追加不同个数的间隔符，但是这种做法会使得代码非常复杂，那么有没有其他更加简单通用的做法呢？</p>
<p>用过 PyCharm 的用户应该知道，大部分 IDE 软件都具备自动格式化代码的功能，其实现机制是通过第三方插件，典型的例如 <a href="https://link.zhihu.com/?target=https://github.com/google/yapf/">YAPF</a> 库, YAPF 是 Google 开发的一个用来格式化 Python 代码工具，其实现了 PEP8 规范，因此我们可以借助 YAPF 库对字典对象进行格式化，使其输出符合 PEP8 规范。其核心 API 为：</p>
<pre><code>from yapf.yapflib.yapf_api import FormatCode
# 定义 格式化输出为 pep8 
yapf_style = dict(
    based_on_style=&#39;pep8&#39;,
    blank_line_before_nested_class_or_def=True,
    split_before_expression_after_opening_paren=True)

# 输入要求：没有经过格式化，但是能够被 FormatCode 解析的 dict_text
# 输出就已经符合 pep8 规范了，可以直接打印
text, _ = FormatCode(dict_text, style_config=yapf_style, verify=True)
</code></pre>
<p>上述 API 的核心是对于任意字典对象，如何生成 <code>dict_text</code>，MMCV 中对应的代码是 <code>Config.pretty_text</code> ，其最简实现如下：</p>
<pre><code>def pretty_text(src_dict):

    def _format_basic_types(k, v):
        if isinstance(v, str):
            v_str = f&quot;&#39;&#123;v&#125;&#39;&quot;
        else:
            v_str = str(v)

        attr_str = f&#39;&#123;str(k)&#125;=&#123;v_str&#125;&#39;

        return attr_str

    def _format_list(k, v):
        if all(isinstance(_, dict) for _ in v):
            v_str = &#39;[\n&#39;
            v_str += &#39;\n&#39;.join(
                f&#39;dict(&#123;_format_dict(v_)&#125;),&#39;
                for v_ in v).rstrip(&#39;,&#39;)
            attr_str = f&#39;&#123;str(k)&#125;=&#123;v_str&#125;&#39;
            attr_str = attr_str + &#39;]&#39;
        else:
            attr_str = _format_basic_types(k, v)
        return attr_str

    # 核心逻辑
    def _format_dict(input_dict, outest_level=False):
        r = &#39;&#39;
        s = []

        for idx, (k, v) in enumerate(input_dict.items()):
            end = &#39;&#39; if outest_level else &#39;,&#39;  # 需要符合 pep8 格式
            if isinstance(v, dict):
                v_str = &#39;\n&#39; + _format_dict(v)  # 递归调用
                attr_str = f&#39;&#123;str(k)&#125;=dict(&#123;v_str&#125;&#39;
                attr_str = attr_str + &#39;)&#39; + end
            elif isinstance(v, list):
                attr_str = _format_list(k, v) + end
            else:
                attr_str = _format_basic_types(k, v) + end

            s.append(attr_str)
        r += &#39;\n&#39;.join(s)
        return r

    # outest_level 表示字典最外层
    # 仅仅需要把 dict 按照行排列切割好就行，后面的每行如何格式化采用 pep8 标准自动执行
    text = _format_dict(src_dict, outest_level=True)

    yapf_style = dict(
        based_on_style=&#39;pep8&#39;,
        blank_line_before_nested_class_or_def=True,
        split_before_expression_after_opening_paren=True)
    text, _ = FormatCode(text, style_config=yapf_style, verify=True)

    return text
</code></pre>
<p>示例如下：</p>
<pre><code># 字典对象：
A=dict(b=1, c=dict(d=2, e=dict(e1=3, e2=1), f=4), g=[1, 2, 3])

# print(A)
# 直接打印
&#123;&#39;b&#39;: 1, &#39;c&#39;: &#123;&#39;d&#39;: 2, &#39;e&#39;: &#123;&#39;e1&#39;: 3, &#39;e2&#39;: 1&#125;, &#39;f&#39;: 4&#125;, &#39;g&#39;: [1, 2, 3]&#125;

# _format_dict 转化输出
b=1,
c=dict(
d=2,
e=dict(
e1=3,
e2=1,),
f=4,),
g=[1, 2, 3],

# FormatCode 输出
b = 1,
c = dict(
    d=2,
    e=dict(
        e1=3,
        e2=1,
    ),
    f=4,
),
g = [1, 2, 3],
</code></pre>
<h3 id="Config-fromfile-实现"><a href="#Config-fromfile-实现" class="headerlink" title="Config.fromfile 实现"></a>Config.fromfile 实现</h3><p><code>Config.fromfile</code> 是 Config 类中应用最为广泛的函数，有必要对其实现进行分析。其最上层大致逻辑是：</p>
<pre><code>def fromfile(filename,
             use_predefined_variables=True,
             import_custom_modules=True):
    # 对文件进行解析，返回字典和文本内容，其中文本内容就是文件中的原始未解析前内容
    cfg_dict, cfg_text = Config._file2dict(filename,
                                           use_predefined_variables)
    # 如果需要进行定制化导入，则对模块进行导入
    if import_custom_modules and cfg_dict.get(&#39;custom_imports&#39;, None):
        import_modules_from_strings(**cfg_dict[&#39;custom_imports&#39;])

    # 生成 Config 对象，返回
    return Config(cfg_dict, cfg_text=cfg_text, filename=filename)
</code></pre>
<p>几乎所有复杂操作都在 <code>Config._file2dict</code> 中。要特别注意 <code>cfg_text</code> 到底是啥？假设配置文件是 <code>retinanet_r50_fpn_1x_coco.py</code> ，其内容是：</p>
<pre><code>_base_ = [
    &#39;../_base_/models/retinanet_r50_fpn.py&#39;,
    &#39;../_base_/datasets/coco_detection.py&#39;,
    &#39;../_base_/schedules/schedule_1x.py&#39;, 		   &#39;../_base_/default_runtime.py&#39;
]
# optimizer
optimizer = dict(type=&#39;SGD&#39;, lr=0.01, momentum=0.9,weight_decay=0.0001)
</code></pre>
<p><code>cfg_text</code> 是遍历所有 base 文件，然后读取其文本内容，并且在前面追加文件路径，最后才追加当前文件内容，其返回的内容大致如下：</p>
<pre><code class="python">retinanet_r50_fpn.py 文件绝对路径
retinanet_r50_fpn.py 文件内容
coco_detection.py 文件绝对路径
coco_detection.py 文件内容
...
retinanet_r50_fpn_1x_coco.py 文件绝对路径
_base_ = [
    &#39;../_base_/models/retinanet_r50_fpn.py&#39;,
    &#39;../_base_/datasets/coco_detection.py&#39;,
    &#39;../_base_/schedules/schedule_1x.py&#39;, &#39;../_base_/default_runtime.py&#39;
]
# optimizer
optimizer = dict(type=&#39;SGD&#39;, lr=0.01, momentum=0.9, weight_decay=0.0001)
</code></pre>
<p>可以知道：<strong>cfg_dict 是多个文件合并后的最终字典内容，<code>Config.pretty_text</code> 打印的是 cfg_dict 内容，而不是 cfg_text</strong>。</p>
<p>_file2dict 函数大概逻辑是：</p>
<pre><code># 1. 先解析最上层文件
mod = import_module(temp_module_name)
cfg_dict = &#123;
    name: value
    for name, value in mod.__dict__.items()
    if not name.startswith(&#39;__&#39;)
&#125;

if BASE_KEY in cfg_dict：
  # 2. 解析 base 文件
  for f in base_filename:
    _cfg_dict, _cfg_text = Config._file2dict(osp.join(cfg_dir, f))
    cfg_dict_list.append(_cfg_dict)

  # 3. 不允许多个 base 文件有重复 key
  for c in cfg_dict_list:
    if len(base_cfg_dict.keys() &amp; c.keys()) &gt; 0:
        raise KeyError(&#39;Duplicate key is not allowed among bases&#39;)
  # 4. 合并 base 内容到同一个字典中
  base_cfg_dict = Config._merge_a_into_b(cfg_dict, base_cfg_dict)
</code></pre>
<h1 id="fileio"><a href="#fileio" class="headerlink" title="fileio"></a>fileio</h1><h2 id="fileio-1"><a href="#fileio-1" class="headerlink" title="fileio"></a><strong>fileio</strong></h2><h6 id="涉及文件读写的-FileHandler"><a href="#涉及文件读写的-FileHandler" class="headerlink" title="涉及文件读写的 FileHandler"></a>涉及文件读写的 FileHandler</h6><p>根据待读写的文件后缀名自动选择对应的 handler 进行具体操作</p>
<pre><code>mmcv/mmcv/fileio/handlers/base.py
</code></pre>
<img src="../images/mmlab/image-20230719161713484.png" alt="image-20230719161713484" style="zoom:50%;" />

<h2 id="file-client"><a href="#file-client" class="headerlink" title="file_client"></a><em>file_client</em></h2><p>其作用是<strong>对外提供统一的文件内容获取 API，主要用于训练过程中数据的后端读取，通过用户选择默认或者自定义不同的 FileClient 后端，可以轻松实现文件缓存、文件加速读取等等功能</strong>。</p>
<p>mmcv\fileio\file_client.py</p>
<p><img src="/../images/mmlab/image-20230719194105940.png" alt="image-20230719194105940"></p>
<p>图片的读取一般包括两个步骤：给定文件路径，读取文件内容（字节流），对文件字节内容进行解码</p>
<p>第2步文件解码非常简单，通过 <code>mmcv.imfrombytes</code> 函数即可实现，该函数会对不同图片格式进行相应解码。</p>
<h3 id="class-FileClient"><a href="#class-FileClient" class="headerlink" title="class FileClient"></a>class FileClient</h3><pre><code>class FileClient:
    
    #实现的5种后端
    _backends = &#123;
            &#39;disk&#39;: HardDiskBackend,
            &#39;ceph&#39;: CephBackend,
            &#39;memcached&#39;: MemcachedBackend,
            &#39;lmdb&#39;: LmdbBackend,
            &#39;petrel&#39;: PetrelBackend,
            &#39;http&#39;: HTTPBackend,
        &#125;
    _prefix_to_backends = &#123;
            &#39;s3&#39;: PetrelBackend,
            &#39;http&#39;: HTTPBackend,
            &#39;https&#39;: HTTPBackend,
        &#125;
        
   #对外提供两个接口，所有后端必须实现
   def get(self, filepath: Union[str, Path]) -&gt; Union[bytes, memoryview]:
           return self.client.get(filepath)
   
   def get_text(self, filepath: Union[str, Path], encoding=&#39;utf-8&#39;) -&gt; str:
           return self.client.get_text(filepath, encoding)
</code></pre>
<h3 id="mmcv-imfrombytes"><a href="#mmcv-imfrombytes" class="headerlink" title="mmcv.imfrombytes"></a>mmcv.imfrombytes</h3><p><code>mmcv.imfrombytes</code>函数的作用是将图像的二进制数据转换为一个多维数组（<code>numpy.ndarray</code>）表示的图像数据。</p>
<ul>
<li><code>content</code>：表示图像的二进制数据或者<code>numpy.ndarray</code>数组。</li>
<li><code>flag</code>：表示图像读取的方式。默认值为<code>-1</code>，表示根据图像数据自动检测读取方式。</li>
<li><code>backend</code>：表示图像读取的后端。默认值为<code>pillow</code>，表示使用Pillow库进行图像读取。</li>
</ul>
<h3 id="‘BaseStorageBackend’"><a href="#‘BaseStorageBackend’" class="headerlink" title="‘BaseStorageBackend’"></a>‘BaseStorageBackend’</h3><pre><code>class BaseStorageBackend(metaclass=ABCMeta):

    _allow_symlink = False

    @property
    def name(self):
        return self.__class__.__name__

    @property
    def allow_symlink(self):
        return self._allow_symlink

    @abstractmethod
    def get(self, filepath):
        pass

    @abstractmethod
    def get_text(self, filepath):
        pass
</code></pre>
<h3 id="‘FileClient’"><a href="#‘FileClient’" class="headerlink" title="‘FileClient’"></a>‘FileClient’</h3><h3 id="HardDiskBackend-BaseStorageBackend"><a href="#HardDiskBackend-BaseStorageBackend" class="headerlink" title="HardDiskBackend(BaseStorageBackend)"></a>HardDiskBackend(BaseStorageBackend)</h3><pre><code>    def get(self, filepath: Union[str, Path]) -&gt; bytes:
        &quot;&quot;&quot;Read data from a given ``filepath`` with &#39;rb&#39; mode.

        Args:
            filepath (str or Path): Path to read data.

        Returns:
            bytes: Expected bytes object.
        &quot;&quot;&quot;
        with open(filepath, &#39;rb&#39;) as f:
            value_buf = f.read()
        return value_buf
</code></pre>
<h3 id="LmdbBackend-BaseStorageBackend"><a href="#LmdbBackend-BaseStorageBackend" class="headerlink" title="LmdbBackend(BaseStorageBackend)"></a>LmdbBackend(BaseStorageBackend)</h3><pre><code>    &quot;&quot;&quot;Lmdb storage backend.

    Args:
        db_path (str): Lmdb database path.
        readonly (bool, optional): Lmdb environment parameter. If True,
            disallow any write operations. Default: True.
        lock (bool, optional): Lmdb environment parameter. If False, when
            concurrent access occurs, do not lock the database. Default: False.
        readahead (bool, optional): Lmdb environment parameter. If False,
            disable the OS filesystem readahead mechanism, which may improve
            random read performance when a database is larger than RAM.
            Default: False.

    Attributes:
        db_path (str): Lmdb database path.
    &quot;&quot;&quot;
</code></pre>
<pre><code>class LmdbBackend(BaseStorageBackend):


    def __init__(self,
                 db_path,
                 readonly=True,
                 lock=False,
                 readahead=False,
                 **kwargs):
        try:
            import lmdb  # NOQA
        except ImportError:
            raise ImportError(&#39;Please install lmdb to enable LmdbBackend.&#39;)

        self.db_path = str(db_path)
        self.readonly = readonly
        self.lock = lock
        self.readahead = readahead
        self.kwargs = kwargs
        self._client = None
    
   def get(self, filepath):
        &quot;&quot;&quot;Get values according to the filepath.

        Args:
            filepath (str | obj:`Path`): Here, filepath is the lmdb key.
        &quot;&quot;&quot;
        if self._client is None:
            self._client = self._get_client()

        with self._client.begin(write=False) as txn:
            value_buf = txn.get(str(filepath).encode(&#39;utf-8&#39;))
        return value_buf
</code></pre>
<h3 id="fileclient用法"><a href="#fileclient用法" class="headerlink" title="fileclient用法"></a>fileclient用法</h3><pre><code>@PIPELINES.register_module()
class LoadImageFromFile(object):  # 加载图片到内存中

    def __init__(self,
                 to_float32=False,
                 color_type=&#39;color&#39;,
                 file_client_args=dict(backend=&#39;disk&#39;)):
        self.to_float32 = to_float32
        self.color_type = color_type
        # 默认是 disk 后端
        self.file_client_args = file_client_args.copy()
        self.file_client = None

    def __call__(self, results):
        if self.file_client is None:
            self.file_client = mmcv.FileClient(**self.file_client_args)
        # 读取图片字节内容
        img_bytes = self.file_client.get(filename)
        # 对字节内容进行解码
        img = mmcv.imfrombytes(img_bytes, flag=self.color_type)
        ...
        return results
</code></pre>
<h3 id="实列使用"><a href="#实列使用" class="headerlink" title="实列使用"></a>实列使用</h3><p><strong>annotations 文件和图片文件不在同一个地方</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/339190576">https://zhuanlan.zhihu.com/p/339190576</a></p>
<p>具体修改还是看知乎这里</p>
<pre><code>import mmcv
from mmcv import BaseStorageBackend, FileClient
# 通过 FileClient.register_backend可以注册到_backends 字典中
# 自己注册的
@FileClient.register_backend(&#39;remote&#39;)			
class RemoteUrlBackend(BaseStorageBackend):

    def __init__(self, path_mapping):
        assert isinstance(path_mapping, dict)
        self.path_mapping = path_mapping

    def get(self, filepath):
        filepath = str(filepath)

        # 本地相对路径替换为远程 url
        for k, v in self.path_mapping.items():
            filepath = filepath.replace(k, v)

        # 拉取远程图片(可能比较复杂)
        value_buf = self._get_remote_image()

        return value_buf

    def get_text(self, filepath):
        raise NotImplementedError

    def _get_remote_image(self):
        pass
</code></pre>
<h2 id="io"><a href="#io" class="headerlink" title="io"></a><em>io</em></h2><pre><code># Copyright (c) OpenMMLab. All rights reserved.
from io import BytesIO, StringIO
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, TextIO, Union	#它用于声明函数和变量的参数类型和返回值类型。

from ..utils import is_list_of
from .file_client import FileClient
from .handlers import BaseFileHandler, JsonHandler, PickleHandler, YamlHandler

FileLikeObject = Union[TextIO, StringIO, BytesIO]

file_handlers = &#123;
    &#39;json&#39;: JsonHandler(),
    &#39;yaml&#39;: YamlHandler(),
    &#39;yml&#39;: YamlHandler(),
    &#39;pickle&#39;: PickleHandler(),
    &#39;pkl&#39;: PickleHandler()
&#125;


def load(file: Union[str, Path, FileLikeObject],
         file_format: Optional[str] = None,
         file_client_args: Optional[Dict] = None,
         **kwargs):
    &quot;&quot;&quot;Load data from json/yaml/pickle files.

    This method provides a unified api for loading data from serialized files.

    Note:
        In v1.3.16 and later, ``load`` supports loading data from serialized
        files those can be storaged in different backends.

    Args:
        file (str or :obj:`Path` or file-like object): Filename or a file-like
            object.
        file_format (str, optional): If not specified, the file format will be
            inferred from the file extension, otherwise use the specified one.
            Currently supported formats include &quot;json&quot;, &quot;yaml/yml&quot; and
            &quot;pickle/pkl&quot;.
        file_client_args (dict, optional): Arguments to instantiate a
            FileClient. See :class:`mmcv.fileio.FileClient` for details.
            Default: None.

    Examples:
        &gt;&gt;&gt; load(&#39;/path/of/your/file&#39;)  # file is storaged in disk
        &gt;&gt;&gt; load(&#39;https://path/of/your/file&#39;)  # file is storaged in Internet
        &gt;&gt;&gt; load(&#39;s3://path/of/your/file&#39;)  # file is storaged in petrel

    Returns:
        The content from the file.
    &quot;&quot;&quot;
    if isinstance(file, Path):
        file = str(file)
    if file_format is None and isinstance(file, str):
        file_format = file.split(&#39;.&#39;)[-1]
    if file_format not in file_handlers:
        raise TypeError(f&#39;Unsupported format: &#123;file_format&#125;&#39;)

    handler = file_handlers[file_format]
    f: FileLikeObject
    if isinstance(file, str):
        file_client = FileClient.infer_client(file_client_args, file)
        if handler.str_like:
            with StringIO(file_client.get_text(file)) as f:
                obj = handler.load_from_fileobj(f, **kwargs)
        else:
            with BytesIO(file_client.get(file)) as f:
                obj = handler.load_from_fileobj(f, **kwargs)
    elif hasattr(file, &#39;read&#39;):
        obj = handler.load_from_fileobj(file, **kwargs)
    else:
        raise TypeError(&#39;&quot;file&quot; must be a filepath str or a file-object&#39;)
    return obj


def dump(obj: Any,
         file: Optional[Union[str, Path, FileLikeObject]] = None,
         file_format: Optional[str] = None,
         file_client_args: Optional[Dict] = None,
         **kwargs):
    &quot;&quot;&quot;Dump data to json/yaml/pickle strings or files.

    This method provides a unified api for dumping data as strings or to files,
    and also supports custom arguments for each file format.

    Note:
        In v1.3.16 and later, ``dump`` supports dumping data as strings or to
        files which is saved to different backends.

    Args:
        obj (any): The python object to be dumped.
        file (str or :obj:`Path` or file-like object, optional): If not
            specified, then the object is dumped to a str, otherwise to a file
            specified by the filename or file-like object.
        file_format (str, optional): Same as :func:`load`.
        file_client_args (dict, optional): Arguments to instantiate a
            FileClient. See :class:`mmcv.fileio.FileClient` for details.
            Default: None.

    Examples:
        &gt;&gt;&gt; dump(&#39;hello world&#39;, &#39;/path/of/your/file&#39;)  # disk
        &gt;&gt;&gt; dump(&#39;hello world&#39;, &#39;s3://path/of/your/file&#39;)  # ceph or petrel

    Returns:
        bool: True for success, False otherwise.
    &quot;&quot;&quot;
    if isinstance(file, Path):
        file = str(file)
    if file_format is None:
        if isinstance(file, str):
            file_format = file.split(&#39;.&#39;)[-1]
        elif file is None:
            raise ValueError(
                &#39;file_format must be specified since file is None&#39;)
    if file_format not in file_handlers:
        raise TypeError(f&#39;Unsupported format: &#123;file_format&#125;&#39;)
    f: FileLikeObject
    handler = file_handlers[file_format]
    if file is None:
        return handler.dump_to_str(obj, **kwargs)
    elif isinstance(file, str):
        file_client = FileClient.infer_client(file_client_args, file)
        if handler.str_like:
            with StringIO() as f:
                handler.dump_to_fileobj(obj, f, **kwargs)
                file_client.put_text(f.getvalue(), file)
        else:
            with BytesIO() as f:
                handler.dump_to_fileobj(obj, f, **kwargs)
                file_client.put(f.getvalue(), file)
    elif hasattr(file, &#39;write&#39;):
        handler.dump_to_fileobj(obj, file, **kwargs)
    else:
        raise TypeError(&#39;&quot;file&quot; must be a filename str or a file-object&#39;)


def _register_handler(handler: BaseFileHandler,
                      file_formats: Union[str, List[str]]) -&gt; None:
    &quot;&quot;&quot;Register a handler for some file extensions.

    Args:
        handler (:obj:`BaseFileHandler`): Handler to be registered.
        file_formats (str or list[str]): File formats to be handled by this
            handler.
    &quot;&quot;&quot;
    if not isinstance(handler, BaseFileHandler):
        raise TypeError(
            f&#39;handler must be a child of BaseFileHandler, not &#123;type(handler)&#125;&#39;)
    if isinstance(file_formats, str):
        file_formats = [file_formats]
    if not is_list_of(file_formats, str):
        raise TypeError(&#39;file_formats must be a str or a list of str&#39;)
    for ext in file_formats:
        file_handlers[ext] = handler


def register_handler(file_formats: Union[str, list], **kwargs) -&gt; Callable:

    def wrap(cls):
        _register_handler(cls(**kwargs), file_formats)
        return cls

    return wrap
</code></pre>
<h3 id="‘load’"><a href="#‘load’" class="headerlink" title="‘load’"></a>‘load’</h3><pre><code class="python">
    handler = file_handlers[file_format]
    file_client = FileClient.infer_client(file_client_args, file)
    if isinstance(file, str):
        file_client = FileClient.infer_client(file_client_args, file) 
        # file_client_args 一般是None
        # file字符串路径名
        if handler.str_like:
            with StringIO(file_client.get_text(file)) as f:
                obj = handler.load_from_fileobj(f, **kwargs)
        else:
            with BytesIO(file_client.get(file)) as f:
                obj = handler.load_from_fileobj(f, **kwargs)
    elif hasattr(file, &#39;read&#39;):
        obj = handler.load_from_fileobj(file, **kwargs)
    else:
        raise TypeError(&#39;&quot;file&quot; must be a filepath str or a file-object&#39;)
    return obj
</code></pre>
<h3 id="‘dump’"><a href="#‘dump’" class="headerlink" title="‘dump’"></a>‘dump’</h3><h3 id="‘register-handler’"><a href="#‘register-handler’" class="headerlink" title="‘register_handler’"></a>‘register_handler’</h3><h2 id="handlers"><a href="#handlers" class="headerlink" title="handlers"></a><em>handlers</em></h2><h3 id="‘BaseFileHandler’"><a href="#‘BaseFileHandler’" class="headerlink" title="‘BaseFileHandler’"></a>‘BaseFileHandler’</h3><pre><code class="python">from abc import ABCMeta, abstractmethod
# 继承ABCMeta元类，使其无法直接实例化
class BaseFileHandler(metaclass=ABCMeta):

    #@abstractmethod表示子类必须要实现该方法，否则报错
    # 文件读取
    @abstractmethod
    def load_from_fileobj(self, file, **kwargs):
        pass
    # 文件存储，需要传入对象obj和file
    @abstractmethod
    def dump_to_fileobj(self, obj, file, **kwargs):
        pass

    #dump成字符串返回，当你不想保存时候使用
    @abstractmethod
    def dump_to_str(self, obj, **kwargs):
        pass
    # 对外实际上是采用下面两个api
    def load_from_path(self, filepath, mode=&#39;r&#39;, **kwargs):
        with open(filepath, mode) as f:
            return self.load_from_fileobj(f, **kwargs)

    def dump_to_path(self, obj, filepath, mode=&#39;w&#39;, **kwargs):
        with open(filepath, mode) as f:
            self.dump_to_fileobj(obj, f, **kwargs)
</code></pre>
<h4 id="基方法load-from-fileobj"><a href="#基方法load-from-fileobj" class="headerlink" title="基方法load_from_fileobj"></a>基方法load_from_fileobj</h4><h4 id="基方法dump-to-fileobj"><a href="#基方法dump-to-fileobj" class="headerlink" title="基方法dump_to_fileobj"></a>基方法dump_to_fileobj</h4><h4 id="基方法dump-to-str"><a href="#基方法dump-to-str" class="headerlink" title="基方法dump_to_str"></a>基方法dump_to_str</h4><h4 id="load-from-path"><a href="#load-from-path" class="headerlink" title="load_from_path"></a>load_from_path</h4><h4 id="dump-to-path"><a href="#dump-to-path" class="headerlink" title="dump_to_path"></a>dump_to_path</h4><h3 id="‘JsonHandler’"><a href="#‘JsonHandler’" class="headerlink" title="‘JsonHandler’"></a>‘JsonHandler’</h3><pre><code># Copyright (c) OpenMMLab. All rights reserved.
import json

import numpy as np

from .base import BaseFileHandler


def set_default(obj):
    # 这些数据类型没办法序列化，比如numpy数组，就要变成列表
    # 创建一个set my_set = &#123;1, 2, 3, 4, 5&#125;
    # &lt;class &#39;range&#39;&gt; range()函数返回一个表示范围的对象，而不是一个列表。
    # range(1, 6)
    if isinstance(obj, (set, range)):
        return list(obj)
    elif isinstance(obj, np.ndarray):
        return obj.tolist()
    elif isinstance(obj, np.generic):
        return obj.item()
    raise TypeError(f&#39;&#123;type(obj)&#125; is unsupported for json dump&#39;)


class JsonHandler(BaseFileHandler):

    def load_from_fileobj(self, file):
        return json.load(file)

    def dump_to_fileobj(self, obj, file, **kwargs):
        kwargs.setdefault(&#39;default&#39;, set_default)
        json.dump(obj, file, **kwargs)

    def dump_to_str(self, obj, **kwargs):
        kwargs.setdefault(&#39;default&#39;, set_default)
        return json.dumps(obj, **kwargs)
</code></pre>
<h3 id="‘PickleHandler’"><a href="#‘PickleHandler’" class="headerlink" title="‘PickleHandler’"></a>‘PickleHandler’</h3><pre><code># Copyright (c) OpenMMLab. All rights reserved.
import pickle

from .base import BaseFileHandler


class PickleHandler(BaseFileHandler):

    str_like = False

    def load_from_fileobj(self, file, **kwargs):
        return pickle.load(file, **kwargs)

    def load_from_path(self, filepath, **kwargs):
        return super().load_from_path(filepath, mode=&#39;rb&#39;, **kwargs)

    def dump_to_str(self, obj, **kwargs):
        kwargs.setdefault(&#39;protocol&#39;, 2)
        return pickle.dumps(obj, **kwargs)

    def dump_to_fileobj(self, obj, file, **kwargs):
        kwargs.setdefault(&#39;protocol&#39;, 2)
        pickle.dump(obj, file, **kwargs)

    def dump_to_path(self, obj, filepath, **kwargs):
        super().dump_to_path(obj, filepath, mode=&#39;wb&#39;, **kwargs)
</code></pre>
<h3 id="‘YamlHandler’"><a href="#‘YamlHandler’" class="headerlink" title="‘YamlHandler’"></a>‘YamlHandler’</h3><pre><code># Copyright (c) OpenMMLab. All rights reserved.
import yaml

try:
    from yaml import CDumper as Dumper
    from yaml import CLoader as Loader
except ImportError:
    from yaml import Loader, Dumper  # type: ignore

from .base import BaseFileHandler  # isort:skip


class YamlHandler(BaseFileHandler):

    def load_from_fileobj(self, file, **kwargs):
        kwargs.setdefault(&#39;Loader&#39;, Loader)
        return yaml.load(file, **kwargs)

    def dump_to_fileobj(self, obj, file, **kwargs):
        kwargs.setdefault(&#39;Dumper&#39;, Dumper)
        yaml.dump(obj, file, **kwargs)

    def dump_to_str(self, obj, **kwargs):
        kwargs.setdefault(&#39;Dumper&#39;, Dumper)
        return yaml.dump(obj, **kwargs)
</code></pre>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><h6 id="‘list-from-file"><a href="#‘list-from-file" class="headerlink" title="‘list_from_file"></a>‘list_from_file</h6><h6 id="dict-from-file"><a href="#dict-from-file" class="headerlink" title="dict_from_file"></a>dict_from_file</h6><h2 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h2><pre><code class="python">def register_handler(file_formats, **kwargs):

    def wrap(cls):
        # 这句话其实核心是：file_handlers[ext] = handler
        # 把我们写的handler类设置到file_handlers的字典中
        _register_handler(cls(**kwargs), file_formats)
        return cls

    return wrap
</code></pre>
<pre><code>@register_handler(&#39;npy&#39;)
class NpyHandler(BaseFileHandler):
    def load_from_fileobj(self, file, **kwargs):
        return np.load(file)

    def dump_to_fileobj(self, obj, file, **kwargs):
        np.save(file, obj)

    def dump_to_str(self, obj, **kwargs):
        # 实际上这么写没有意义，这里只是举例
        return obj.tobytes()
</code></pre>
<p><img src="/../images/mmlab/image-20230719192925462.png" alt="image-20230719192925462"></p>
<p>在调用的时候，我们需要额外传入 mode 参数，原因是默认的 mode 参数是 ‘r’ 或者 ‘w’，但是在 numpy 中需要是 byte 格式。</p>
<h2 id="杂-1"><a href="#杂-1" class="headerlink" title="杂"></a>杂</h2><p>在Python中，如果要定义一个抽象类，需要使用abc模块。下面是一个使用@abstractmethod装饰器定义抽象方法的例子：</p>
<pre><code>from abc import ABC, abstractmethod

class MyAbstractClass(ABC):
    @abstractmethod
    def my_abstract_method(self):
        pass
</code></pre>
<p>自己写装饰器</p>
<p>先定义一个装饰器</p>
<pre><code>def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(&#39;Before the function is called.&#39;)
        result = func(*args, **kwargs)
        print(&#39;After the function is called.&#39;)
        return result
    return wrapper
</code></pre>
<p>上面的代码定义了一个名为my_decorator的装饰器，它接受一个函数作为参数，并返回一个新的函数wrapper。wrapper函数在调用原函数之前和之后会打印一些信息，以增强原函数的功能。使用装饰器时，只需要在原函数前面加上@my_decorator即可将装饰器应用到原函数中，例如：</p>
<pre><code>@my_decorator
def my_function():
    print(&#39;This is my function.&#39;)
</code></pre>
<p>在上面的例子中，my_function函数被@my_decorator装饰器装饰，当调用my_function函数时，会先打印’Before the function is called.’，然后执行原函数的代码，最后打印’After the function is called.’。</p>
<h6 id="文件获取后端-FileClient"><a href="#文件获取后端-FileClient" class="headerlink" title="文件获取后端 FileClient"></a>文件获取后端 FileClient</h6><p>主要用于训练过程中数据的读取，通过用户选择或者自定义不同的 FileClient 后端，可以轻松实现文件缓存、文件加速读取等功能</p>
<h6 id="np-generic举例"><a href="#np-generic举例" class="headerlink" title="np.generic举例"></a>np.generic举例</h6><pre><code>import numpy as np

# 创建一个numpy数组
my_array = np.array([1, 2, 3], dtype=np.int32)

# 将numpy数组转换为Python列表
my_list = my_array.tolist()

# 打印Python列表
print(my_list)

# 将numpy的generic类型转换为Python内置类型
my_int32 = np.int32(3)
my_int = my_int32.item()

# 打印转换后的Python内置类型
print(type(my_int))  # &lt;class &#39;int&#39;&gt;
</code></pre>
<h6 id="类型提示-Type-Hints-语法"><a href="#类型提示-Type-Hints-语法" class="headerlink" title="类型提示(Type Hints)语法"></a>类型提示(Type Hints)语法</h6><pre><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union
</code></pre>
<p><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union</code>这行代码是Python中的类型提示(Type Hints)语法，它用于声明函数和变量的参数类型和返回值类型。这样做可以提高代码的可读性、可维护性和可靠性。</p>
<p>具体来说，这行代码中声明了以下类型：</p>
<ul>
<li><code>Any</code>: 表示任意类型，相当于不做类型限制。</li>
<li><code>Callable</code>: 表示一个可调用对象，例如函数或方法。</li>
<li><code>Dict</code>: 表示一个字典类型，其中键和值的类型可以是任意类型。</li>
<li><code>List</code>: 表示一个列表类型，其中元素的类型可以是任意类型。</li>
<li><code>Optional</code>: 表示一个可选类型，即参数可以是指定类型或<code>None</code>。</li>
<li><code>TextIO</code>: 表示一个文本流对象，例如文件、标准输入输出等。</li>
<li><code>Union</code>: 表示多个类型中的任意一种类型。</li>
</ul>
<pre><code>def my_function(my_list: List[int], my_dict: Optional[Dict[str, Any]]) -&gt; Union[int, float]:
    # 函数体
    pass
</code></pre>
<p>FileLikeObject &#x3D; Union[TextIO, StringIO, BytesIO]这行代码是Python中的类型提示(Type Hints)语法，用于定义一个新的类型FileLikeObject。在这个代码中，FileLikeObject是一个由Union类型组成的联合类型，它表示可以是TextIO、StringIO或BytesIO类型中的任何一种。</p>
<p>TextIO、StringIO和BytesIO是Python内置的文件流对象，用于处理文本和二进制数据。TextIO可以用于读写文本文件，StringIO可以在内存中读写字符串，BytesIO可以在内存中读写二进制数据。这些对象都实现了文件流操作接口，并且可以像文件一样读写数据。</p>
<pre><code>FileLikeObject = Union[TextIO, StringIO, BytesIO]
</code></pre>
<p>f是一个变量名，FileLikeObject是该变量的类型。</p>
<pre><code>f: FileLikeObject
</code></pre>
<h6 id="python-property"><a href="#python-property" class="headerlink" title="python @property"></a>python @property</h6><p>用于将一个方法转换为属性调用。在Python中，属性通常被视为类的一部分，它们提供了一种简单的方式来访问和修改对象的状态。</p>
<p>通过将一个方法标记为@property，我们可以将它转换为一个只读属性。这意味着，当我们访问该属性时，实际上是调用了该方法，并返回了它的返回值。</p>
<pre><code>class MyClass:
    @property
    def name(self):
        return self.__class__.__name__

obj = MyClass()
print(obj.name)  # 输出 &quot;MyClass&quot;
</code></pre>
<h6 id="python-abstractmethod"><a href="#python-abstractmethod" class="headerlink" title="python @abstractmethod"></a>python @abstractmethod</h6><p>用于将一个方法定义为抽象方法。抽象方法是一种特殊的方法，它没有具体的实现，只是定义了一个接口，需要在子类中进行实现。</p>
<h6 id="python-classmethod"><a href="#python-classmethod" class="headerlink" title="python @classmethod"></a>python @classmethod</h6><p>通过将一个方法标记为@classmethod，我们可以将它转换为类方法。在类方法中，第一个参数通常被命名为cls，它指代当前类对象本身。使用cls参数，我们可以在类方法中访问类的属性和方法，从而实现对类的操作。</p>
<pre><code>class MyClass:
    @classmethod
    def add(cls, x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-staticmethod"><a href="#python-staticmethod" class="headerlink" title="python @staticmethod"></a>python @staticmethod</h6><p>静态方法是一种特殊的方法，它不需要访问实例的状态或类的状态，而是仅依赖于传入的参数。通过将一个方法标记为@staticmethod，我们可以将它转换为静态方法。在静态方法中，不需要使用self或cls等参数来引用实例或类对象，而是可以直接使用传入的参数进行计算。</p>
<pre><code>class MyClass:
    @staticmethod
    def add(x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-call"><a href="#python-call" class="headerlink" title="python call"></a>python <strong>call</strong></h6><pre><code>class MyClass:
    def __call__(self, x):
        return x + 1

obj = MyClass()
result = obj(10)
print(result)  # 输出 11
</code></pre>
<h6 id="python-运算符对字典解包"><a href="#python-运算符对字典解包" class="headerlink" title="python **运算符对字典解包"></a>python **运算符对字典解包</h6><pre><code>def my_func(a, b):
    print(a, b)

env = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;
my_func(**env)  # 输出 1 2
</code></pre>
<h6 id="python-字典形参"><a href="#python-字典形参" class="headerlink" title="python 字典形参"></a>python 字典形参</h6><pre><code>def my_func(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_func(a=1, b=2, c=3)  # 输出 a 1 b 2 c 3
</code></pre>
<h6 id="python-占位符"><a href="#python-占位符" class="headerlink" title="python 占位符"></a>python 占位符</h6><pre><code>item1 = &#39;&#123;&#125;&#39;
item2 = &#39;&#123;&#125;/path/to/dir&#39;
item3 = &#39;abc_&#123;&#125;.txt&#39;

item1 = &#39;&#123;&#125;&#39;.format(&#39;filename&#39;)
item2 = &#39;&#123;&#125;/path/to/dir&#39;.format(&#39;C:/&#39;)
item3 = &#39;abc_&#123;&#125;.txt&#39;.format(&#39;file&#39;)
</code></pre>
<h6 id="python-文件"><a href="#python-文件" class="headerlink" title="python 文件"></a>python 文件</h6><p>..&#x2F;a2与..a2一样吗</p>
<p>不完全相同。..&#x2F;a2 和 ..a2 都表示上一级目录下的 a2 目录，但是它们所表示的路径格式不同。</p>
<p>..&#x2F;a2 使用了标准的相对路径格式，其中 .. 表示上一级目录，&#x2F; 表示目录的分隔符，因此 ..&#x2F;a2 表示上一级目录下的 a2 目录。这种表示方法是在文件系统中广泛使用的相对路径格式。</p>
<p>..a2 则是一种非标准的相对路径格式，使用了点号 . 和 .. 表示路径的相对位置。在 Python 等编程语言中，通常使用点号 . 表示当前目录，使用 .. 表示上一级目录，将它们与目录名拼接起来表示相对路径。因此，..a2 可以理解为上一级目录下的 a2 目录，但是这种表示方法在文件系统中并不通用。</p>
<p>总之，..&#x2F;a2 是标准的相对路径格式，而 ..a2 则是一种非标准的相对路径格式，使用时需要注意。</p>
]]></content>
  </entry>
  <entry>
    <title>虚拟环境配置</title>
    <url>/2023/07/15/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h5 id="likemmcv环境名"><a href="#likemmcv环境名" class="headerlink" title="likemmcv环境名"></a>likemmcv环境名</h5><p><a href="https://download.pytorch.org/whl/cu113/torch-1.12.0%2Bcu113-cp39-cp39-linux_x86_64.whl">torch-1.12.0+cu113-cp39-cp39-linux_x86_64.whl</a></p>
<p>python 3.9</p>
<pre><code>mmcv==2.0.0
</code></pre>
<pre><code>pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu113
</code></pre>
<p>conda install cudnn&#x3D;8.9.0  -c <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/</a></p>
<pre><code class="shell">conda install cudnn=8.9.0 -c http://mirrors.aliyun.com/anaconda/pkgs/main
</code></pre>
<p>为了运行DAS,做如下改变：</p>
<p>Successfully installed mmdet-2.14.0 pycocotools-2.0.6 terminaltables-3.1.10</p>
<p>Successfully installed mmsegmentation-1.0.0 prettytable-3.7.0 scipy-1.10.1 wcwidth-0.2.6</p>
<h6 id="PCT复制的mvp"><a href="#PCT复制的mvp" class="headerlink" title="PCT复制的mvp"></a>PCT复制的mvp</h6><p><a href="https://blog.csdn.net/qq_37764129/article/details/102496746">https://blog.csdn.net/qq_37764129/article/details/102496746</a></p>
<p>复制虚拟环境</p>
<h6 id="RLE复制的likepytorch"><a href="#RLE复制的likepytorch" class="headerlink" title="RLE复制的likepytorch"></a>RLE复制的likepytorch</h6>]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title>UniHCP</title>
    <url>/2023/07/21/UniHCP/</url>
    <content><![CDATA[<h1 id="卖点"><a href="#卖点" class="headerlink" title="卖点"></a>卖点</h1><p>使用99.97%共享的参数，</p>
<p>最核心的是最后四个单元统一五个任务！</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://arxiv.org/abs/2303.02936">https://arxiv.org/abs/2303.02936</a></p>
<p><a href="https://github.com/OpenGVLab/HumanBench">https://github.com/OpenGVLab/HumanBench</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/624776660">https://zhuanlan.zhihu.com/p/624776660</a></p>
<h1 id="问题【待学】："><a href="#问题【待学】：" class="headerlink" title="问题【待学】："></a>问题【待学】：</h1><p>思考: 内功看成的是共享位置嵌入，具体是怎么实现的，能不能用生成模型来做？</p>
<p>UNIFIED-IO: A UNIFIED MODEL FOR VISION, LANGUAGE, AND MULTI-MODAL TASKS 这篇论文用到啦VQ-VAE，看看是怎么用的</p>
<p>对于pose的query设计是直接14个关键点变成14，256，还是说怎么样？</p>
<ul>
<li>Masked-attention Mask Transformer for Universal Image Segmentation，这篇论文里面有query关于注意力mask的机制，mask有什么好处？</li>
<li>A Unified Sequence Interface for Vision Tasks，这篇论文使用了VQ-VAE</li>
</ul>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="任务解释机制"><a href="#任务解释机制" class="headerlink" title="任务解释机制"></a>任务解释机制</h2><h3 id="任务引导的解释器"><a href="#任务引导的解释器" class="headerlink" title="任务引导的解释器"></a>任务引导的解释器</h3><p>UniHCP首先将不同任务的图片输入转化为公用的输出空间，而为了适应不同任务的最终输出，在decoder的末尾设计了任务引导的解释器（task-guided interpreter），用极少的参数量构建了四种输出单元，让UniHCP能根据不同任务选择相应的输出单元。同样的，task-guided  interpreter中的参数也是task间共享的。</p>
<p>query独立的设计让其成为了天生的prompt，让UniHCP在promtp tuning方面具有出色的表现和潜力。</p>
<img src="../images/UniHCP/image-20230721105540492.png" alt="image-20230721105540492" style="zoom:150%;" />

<p>特征表示，局部概率图  ,全局概率图  ,边界框坐标 。</p>
<p>共享99.7%的参数量</p>
<p><img src="/../images/UniHCP/image-20230721112749245.png" alt="image-20230721112749245"></p>
<p><img src="/../images/UniHCP/image-20230721113410803.png" alt="image-20230721113410803"></p>
<h3 id="任务无关的Encoder"><a href="#任务无关的Encoder" class="headerlink" title="任务无关的Encoder"></a>任务无关的Encoder</h3><p>UniHCP选用Vision  Transformer(ViT)作为其编码器模型，在此基础上，UniHCP采用了一个共享的可学习位置嵌入(Learnable  Positional  Embedding)，使其可以关注不同人体任务数据中的人体知识本身,而非任务特有的时空结构,这有利于其学习人体知识的共性与内在联结。值得一提的是，共享位置嵌入还可以减少编码器的参数量与计算负载，避免对于不同任务、数据集学习额外的位置嵌入，带来下游部署上的麻烦。</p>
<p>具体来说，我们选择了各个任务中最大图片高、宽的输入（检测中的长边1333像素），下采样16倍后，学习一个所有任务间共享的 84×84 的 Positional Embedding，<em><strong>并根据具体任务的需要，对Positional  Embedding进行interpolation后作为输入。</strong></em></p>
<h3 id="Decoder和任务相关的Queries"><a href="#Decoder和任务相关的Queries" class="headerlink" title="Decoder和任务相关的Queries"></a><strong>Decoder和任务相关的Queries</strong></h3><p>UniHCP的Decoder的所有参数在所有任务之间完全相同，针对不同数据集、不同人体任务有所区别的只有用于查询人体知识的Queries。不同Queries仅激活编码器中相关的人体知识,而不改变其对这些知识的理解。这使Queries的变化不会影响UniHCP对人体知识的表达,所以其可以在不同Queries(任务)间最大限度地复用与迁移所学知识。</p>
<p><img src="/../images/UniHCP/image-20230721113807935.png" alt="image-20230721113807935"></p>
<h3 id="关于query的初始化"><a href="#关于query的初始化" class="headerlink" title="关于query的初始化:"></a>关于query的初始化:</h3><h4 id="pedestrian-detection"><a href="#pedestrian-detection" class="headerlink" title="pedestrian detection"></a>pedestrian detection</h4><p>query初始化采用Anchor DETR的设计，并且tgt不断的refine,query_pos不refine</p>
<h4 id="别的任务"><a href="#别的任务" class="headerlink" title="别的任务"></a>别的任务</h4><p>query的初始化都是随机初始化的</p>
]]></content>
      <tags>
        <tag>pose论文</tag>
      </tags>
  </entry>
  <entry>
    <title>python语法小记</title>
    <url>/2023/07/22/python%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="随机数相关"><a href="#随机数相关" class="headerlink" title="随机数相关"></a>随机数相关</h1><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><pre><code>import random
_rand = random.uniform(0, 1)
</code></pre>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h6 id="从一个文件路径获取文件名os-path-basename"><a href="#从一个文件路径获取文件名os-path-basename" class="headerlink" title="从一个文件路径获取文件名os.path.basename"></a>从一个文件路径获取文件名os.path.basename</h6><pre><code>import os

path = &#39;/path/to/config.cfg&#39;
filename = os.path.basename(path)
print(filename)  # 输出：config.cfg
</code></pre>
<h1 id="复制相关"><a href="#复制相关" class="headerlink" title="复制相关"></a>复制相关</h1><h2 id="普通对象的复制"><a href="#普通对象的复制" class="headerlink" title="普通对象的复制"></a>普通对象的复制</h2><pre><code>a=list()
b=a.copy()
</code></pre>
<h1 id="报错相关"><a href="#报错相关" class="headerlink" title="报错相关"></a>报错相关</h1><h2 id="产生错误"><a href="#产生错误" class="headerlink" title="产生错误"></a>产生错误</h2><h3 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h3><pre><code> raise TypeError(&#39;module must be a class, but got &#123;&#125;&#39;.format(type(module_class)))
</code></pre>
<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="MethodType"><a href="#MethodType" class="headerlink" title="MethodType()"></a>MethodType()</h2><pre><code>from types import MethodType

class MyClass:
    def __init__(self, x):
        self.x = x

def my_method(self):
    print(self.x)

obj = MyClass(123)
obj.my_method = MethodType(my_method, obj)
obj.my_method()  # 输出：123
</code></pre>
<h1 id="SET相关"><a href="#SET相关" class="headerlink" title="SET相关"></a>SET相关</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个 set 对象是一组不重复的元素，其中每个元素都是唯一的。</p>
<pre><code># 创建一个 set 对象
my_set = &#123;1, 2, 3, 4, 5&#125;

# 创建另一个 set 对象
my_set_2 = set([3, 4, 5, 6, 7])
</code></pre>
<pre><code># 获取 set 对象中元素的数量
print(len(my_set))  # 输出 5

# 检查元素是否存在于 set 对象中
print(3 in my_set)  # 输出 True
print(6 in my_set)  # 输出 False

# 将元素添加到 set 对象中
my_set.add(6)
print(my_set)  # 输出 &#123;1, 2, 3, 4, 5, 6&#125;

# 从 set 对象中删除元素
my_set.remove(6)
print(my_set)  # 输出 &#123;1, 2, 3, 4, 5&#125;
</code></pre>
<h1 id="dict相关"><a href="#dict相关" class="headerlink" title="dict相关"></a>dict相关</h1><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p> <code>get</code> 方法用于获取字典中指定键的值。</p>
<pre><code>my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;

# 获取键为 &#39;a&#39; 的值
value1 = my_dict.get(&#39;a&#39;)
print(value1)  # 输出：1

# 获取键为 &#39;d&#39; 的值，返回默认值 None
value2 = my_dict.get(&#39;d&#39;)
print(value2)  # 输出：None

# 获取键为 &#39;d&#39; 的值，返回默认值 0
value3 = my_dict.get(&#39;d&#39;, 0)
print(value3)  # 输出：0
</code></pre>
<h2 id="pop方法"><a href="#pop方法" class="headerlink" title="pop方法"></a>pop方法</h2><p>用于删除并返回指定键的值。</p>
<pre><code>my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;

# 删除键为 &#39;a&#39; 的项，并返回其值
value1 = my_dict.pop(&#39;a&#39;)
print(value1)  # 输出：1
print(my_dict)  # 输出：&#123;&#39;b&#39;: 2, &#39;c&#39;: 3&#125;
</code></pre>
<h2 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault()"></a>setdefault()</h2><p>假设有一个字典<code>my_dict</code>，其初始值为<code>&#123;&#39;a&#39;:1, &#39;b&#39;:2&#125;</code>，我们可以使用<code>setdefault()</code>方法获取某个键值对应的值，如果该键不存在，则新增该键，并将其值设置为默认值：</p>
<pre><code># 定义一个字典
my_dict = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;

# 获取键值为&#39;c&#39;的值，因为该键不存在，所以默认值为3，并将该键值对加入字典中
value = my_dict.setdefault(&#39;c&#39;, 3)

# 输出字典的值
print(my_dict)  # &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;
print(value)    # 3
</code></pre>
<h1 id="class相关"><a href="#class相关" class="headerlink" title="class相关"></a>class相关</h1><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类里面定义，不需要以self做为输入变量的</p>
<pre><code>class MyClass:
    @staticmethod
    def my_static_method():
        print(&quot;This is a static method.&quot;)

# 用类名调用静态方法
MyClass.my_static_method()

# 用实列调用静态方法
a=MyClass()
a.my_static_method()
</code></pre>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><pre><code>class MyClass:
    
    def my_static_method(self):
        print(&quot;This is a static method.&quot;)

    self.my_static_method() #在类里面通过Self.什么便可以调用

# 用实列调用静态方法
a=MyClass()
a.my_static_method()
</code></pre>
<h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>一个类中在 <code>__init__</code> 方法之外定义的变量是类变量（class variable）。类变量是指在类定义中定义的变量，可以被该类的所有实例共享，也可以被该类的任何方法调用和修改。</p>
<pre><code>
class MyClass:
    x = 10

    def __init__(self, y):
        self.y = y

    def add(self):
        return MyClass.x + self.y
</code></pre>
<p><code>MyClass.x</code> 来访问类变量。</p>
<pre><code>class MyClass:
    x = 10
    def __init__(self, x):
        self.x = x

# 创建一个类的实例，并传递参数
obj = MyClass(20)

# 输出实例变量 x 和类变量 x 的值
print(obj.x)   # 输出 20
print(MyClass.x)  # 输出 10
</code></pre>
<h2 id="判断一个对象是否类"><a href="#判断一个对象是否类" class="headerlink" title="判断一个对象是否类"></a>判断一个对象是否类</h2><p>import inspect</p>
<p>inspect.isclass(输入)</p>
<h6 id="判断别的是否对应属性"><a href="#判断别的是否对应属性" class="headerlink" title="判断别的是否对应属性"></a>判断别的是否对应属性</h6><pre><code>isinstance(cfg, dict)
</code></pre>
<h2 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h2><pre><code>class MyClass:
    def __init__(self, x):
        self._x = x

    @property
    def x(self):
        return self._x
</code></pre>
<p><code>@property</code> 装饰器将方法 <code>x</code> 转换为只读属性。该属性的值可以通过访问 <code>my_object.x</code> 来获取，而不需要使用 <code>my_object.x()</code> 的方法调用语法。</p>
<p>使用 <code>@property</code> 装饰器装饰的方法必须满足以下条件：</p>
<ol>
<li><p>方法名与属性名相同。例如，在上面的示例中，方法名为 <code>x</code>，属性名也为 <code>x</code>。</p>
</li>
<li><p>方法没有参数。例如，在上面的示例中，方法 <code>x</code> 没有参数。</p>
</li>
<li><p>方法必须有返回值。例如，在上面的示例中，方法 <code>x</code> 返回属性 <code>_x</code> 的值。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></li>
</ol>
<h2 id="“-repr-“"><a href="#“-repr-“" class="headerlink" title="“_repr_“"></a>“_<em>repr</em>_“</h2><pre><code>class MyClass:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f&quot;MyClass(x=&#123;self.x&#125;, y=&#123;self.y&#125;)&quot;

obj = MyClass(1, 2)
print(obj)  # 输出：MyClass(x=1, y=2)
</code></pre>
<h2 id="“-getattr-“"><a href="#“-getattr-“" class="headerlink" title="“_getattr_“"></a>“_<em>getattr</em>_“</h2><p>它用于获取对象的属性值。getattr()函数有三个参数：对象、属性名称和默认值。</p>
<p>当对象存在指定属性时，getattr()函数将返回该属性的值。如果对象不存在指定属性，则返回默认值（如果指定了的话）。</p>
<pre><code>class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
</code></pre>
<p>我们可以创建一个Person对象p，然后使用getattr()函数获取它的属性值：</p>
<pre><code>p = Person(&#39;Alice&#39;, 25)
name = getattr(p, &#39;name&#39;)
age = getattr(p, &#39;age&#39;)
</code></pre>
<p>具体使用的列子：</p>
<pre><code class="python">from addict import Dict
class ConfigDict(Dict):
    def __getattr__(self, name):
        try:
            value = super(ConfigDict, self).__getattr__(name)
        except KeyError:
            ex = AttributeError(f&quot;&#39;&#123;self.__class__.__name__&#125;&#39; object has no &quot;
                                f&quot;attribute &#39;&#123;name&#125;&#39;&quot;)
        except Exception as e:
            ex = e
        else:
            return value
        raise ex
</code></pre>
<h2 id="“-call-“"><a href="#“-call-“" class="headerlink" title="“_call_“"></a>“_<em>call</em>_“</h2><p>让一个对象像函数一样被调用，</p>
<p>我们可以使用 <code>()</code> 运算符来调用一个函数。当我们调用一个对象时，Python 会首先检查这个对象是否实现了 <code>__call__</code> 方法。如果实现了，Python 就会调用这个方法来执行对象的操作。</p>
<p>注意，首先要先实例化，然后再用实例化后的对象();</p>
<pre><code>class MyObject:
    def __call__(self, arg):
        print(&quot;Calling MyObject with argument:&quot;, arg)
</code></pre>
<pre><code># 创建一个 MyObject 对象
obj = MyObject()

# 调用 obj 对象，将字符串作为参数传递
obj(&quot;Hello, world!&quot;)
</code></pre>
<h1 id="杂-1"><a href="#杂-1" class="headerlink" title="杂"></a>杂</h1><p>在Python中，如果要定义一个抽象类，需要使用abc模块。下面是一个使用@abstractmethod装饰器定义抽象方法的例子：</p>
<pre><code>from abc import ABC, abstractmethod

class MyAbstractClass(ABC):
    @abstractmethod
    def my_abstract_method(self):
        pass
</code></pre>
<p>自己写装饰器</p>
<p>先定义一个装饰器</p>
<pre><code>def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(&#39;Before the function is called.&#39;)
        result = func(*args, **kwargs)
        print(&#39;After the function is called.&#39;)
        return result
    return wrapper
</code></pre>
<p>上面的代码定义了一个名为my_decorator的装饰器，它接受一个函数作为参数，并返回一个新的函数wrapper。wrapper函数在调用原函数之前和之后会打印一些信息，以增强原函数的功能。使用装饰器时，只需要在原函数前面加上@my_decorator即可将装饰器应用到原函数中，例如：</p>
<pre><code>@my_decorator
def my_function():
    print(&#39;This is my function.&#39;)
</code></pre>
<p>在上面的例子中，my_function函数被@my_decorator装饰器装饰，当调用my_function函数时，会先打印’Before the function is called.’，然后执行原函数的代码，最后打印’After the function is called.’。</p>
<h6 id="文件获取后端-FileClient"><a href="#文件获取后端-FileClient" class="headerlink" title="文件获取后端 FileClient"></a>文件获取后端 FileClient</h6><p>主要用于训练过程中数据的读取，通过用户选择或者自定义不同的 FileClient 后端，可以轻松实现文件缓存、文件加速读取等功能</p>
<h6 id="np-generic举例"><a href="#np-generic举例" class="headerlink" title="np.generic举例"></a>np.generic举例</h6><pre><code>import numpy as np

# 创建一个numpy数组
my_array = np.array([1, 2, 3], dtype=np.int32)

# 将numpy数组转换为Python列表
my_list = my_array.tolist()

# 打印Python列表
print(my_list)

# 将numpy的generic类型转换为Python内置类型
my_int32 = np.int32(3)
my_int = my_int32.item()

# 打印转换后的Python内置类型
print(type(my_int))  # &lt;class &#39;int&#39;&gt;
</code></pre>
<h6 id="类型提示-Type-Hints-语法"><a href="#类型提示-Type-Hints-语法" class="headerlink" title="类型提示(Type Hints)语法"></a>类型提示(Type Hints)语法</h6><pre><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union
</code></pre>
<p><code>from typing import Any, Callable, Dict, List, Optional, TextIO, Union</code>这行代码是Python中的类型提示(Type Hints)语法，它用于声明函数和变量的参数类型和返回值类型。这样做可以提高代码的可读性、可维护性和可靠性。</p>
<p>具体来说，这行代码中声明了以下类型：</p>
<ul>
<li><code>Any</code>: 表示任意类型，相当于不做类型限制。</li>
<li><code>Callable</code>: 表示一个可调用对象，例如函数或方法。</li>
<li><code>Dict</code>: 表示一个字典类型，其中键和值的类型可以是任意类型。</li>
<li><code>List</code>: 表示一个列表类型，其中元素的类型可以是任意类型。</li>
<li><code>Optional</code>: 表示一个可选类型，即参数可以是指定类型或<code>None</code>。</li>
<li><code>TextIO</code>: 表示一个文本流对象，例如文件、标准输入输出等。</li>
<li><code>Union</code>: 表示多个类型中的任意一种类型。</li>
</ul>
<pre><code>def my_function(my_list: List[int], my_dict: Optional[Dict[str, Any]]) -&gt; Union[int, float]:
    # 函数体
    pass
</code></pre>
<p>FileLikeObject &#x3D; Union[TextIO, StringIO, BytesIO]这行代码是Python中的类型提示(Type Hints)语法，用于定义一个新的类型FileLikeObject。在这个代码中，FileLikeObject是一个由Union类型组成的联合类型，它表示可以是TextIO、StringIO或BytesIO类型中的任何一种。</p>
<p>TextIO、StringIO和BytesIO是Python内置的文件流对象，用于处理文本和二进制数据。TextIO可以用于读写文本文件，StringIO可以在内存中读写字符串，BytesIO可以在内存中读写二进制数据。这些对象都实现了文件流操作接口，并且可以像文件一样读写数据。</p>
<pre><code>FileLikeObject = Union[TextIO, StringIO, BytesIO]
</code></pre>
<p>f是一个变量名，FileLikeObject是该变量的类型。</p>
<pre><code>f: FileLikeObject
</code></pre>
<h6 id="python-property"><a href="#python-property" class="headerlink" title="python @property"></a>python @property</h6><p>用于将一个方法转换为属性调用。在Python中，属性通常被视为类的一部分，它们提供了一种简单的方式来访问和修改对象的状态。</p>
<p>通过将一个方法标记为@property，我们可以将它转换为一个只读属性。这意味着，当我们访问该属性时，实际上是调用了该方法，并返回了它的返回值。</p>
<pre><code>class MyClass:
    @property
    def name(self):
        return self.__class__.__name__

obj = MyClass()
print(obj.name)  # 输出 &quot;MyClass&quot;
</code></pre>
<h6 id="python-abstractmethod"><a href="#python-abstractmethod" class="headerlink" title="python @abstractmethod"></a>python @abstractmethod</h6><p>用于将一个方法定义为抽象方法。抽象方法是一种特殊的方法，它没有具体的实现，只是定义了一个接口，需要在子类中进行实现。</p>
<h6 id="python-classmethod"><a href="#python-classmethod" class="headerlink" title="python @classmethod"></a>python @classmethod</h6><p>通过将一个方法标记为@classmethod，我们可以将它转换为类方法。在类方法中，第一个参数通常被命名为cls，它指代当前类对象本身。使用cls参数，我们可以在类方法中访问类的属性和方法，从而实现对类的操作。</p>
<pre><code>class MyClass:
    @classmethod
    def add(cls, x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-staticmethod"><a href="#python-staticmethod" class="headerlink" title="python @staticmethod"></a>python @staticmethod</h6><p>静态方法是一种特殊的方法，它不需要访问实例的状态或类的状态，而是仅依赖于传入的参数。通过将一个方法标记为@staticmethod，我们可以将它转换为静态方法。在静态方法中，不需要使用self或cls等参数来引用实例或类对象，而是可以直接使用传入的参数进行计算。</p>
<pre><code>class MyClass:
    @staticmethod
    def add(x, y):
        return x + y

result = MyClass.add(10, 20)
print(result)  # 输出 30
</code></pre>
<h6 id="python-call"><a href="#python-call" class="headerlink" title="python call"></a>python <strong>call</strong></h6><pre><code>class MyClass:
    def __call__(self, x):
        return x + 1

obj = MyClass()
result = obj(10)
print(result)  # 输出 11
</code></pre>
<h6 id="python-运算符对字典解包"><a href="#python-运算符对字典解包" class="headerlink" title="python **运算符对字典解包"></a>python **运算符对字典解包</h6><pre><code>def my_func(a, b):
    print(a, b)

env = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;
my_func(**env)  # 输出 1 2
</code></pre>
<h6 id="python-字典形参"><a href="#python-字典形参" class="headerlink" title="python 字典形参"></a>python 字典形参</h6><pre><code>def my_func(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

my_func(a=1, b=2, c=3)  # 输出 a 1 b 2 c 3
</code></pre>
<h6 id="python-占位符"><a href="#python-占位符" class="headerlink" title="python 占位符"></a>python 占位符</h6><pre><code>item1 = &#39;&#123;&#125;&#39;
item2 = &#39;&#123;&#125;/path/to/dir&#39;
item3 = &#39;abc_&#123;&#125;.txt&#39;

item1 = &#39;&#123;&#125;&#39;.format(&#39;filename&#39;)
item2 = &#39;&#123;&#125;/path/to/dir&#39;.format(&#39;C:/&#39;)
item3 = &#39;abc_&#123;&#125;.txt&#39;.format(&#39;file&#39;)
</code></pre>
<h6 id="python-文件"><a href="#python-文件" class="headerlink" title="python 文件"></a>python 文件</h6><p>..&#x2F;a2与..a2一样吗</p>
<p>不完全相同。..&#x2F;a2 和 ..a2 都表示上一级目录下的 a2 目录，但是它们所表示的路径格式不同。</p>
<p>..&#x2F;a2 使用了标准的相对路径格式，其中 .. 表示上一级目录，&#x2F; 表示目录的分隔符，因此 ..&#x2F;a2 表示上一级目录下的 a2 目录。这种表示方法是在文件系统中广泛使用的相对路径格式。</p>
<p>..a2 则是一种非标准的相对路径格式，使用了点号 . 和 .. 表示路径的相对位置。在 Python 等编程语言中，通常使用点号 . 表示当前目录，使用 .. 表示上一级目录，将它们与目录名拼接起来表示相对路径。因此，..a2 可以理解为上一级目录下的 a2 目录，但是这种表示方法在文件系统中并不通用。</p>
<p>总之，..&#x2F;a2 是标准的相对路径格式，而 ..a2 则是一种非标准的相对路径格式，使用时需要注意。</p>
<h6 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h6><p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p>
<pre><code>def a_new_decorator(a_func):
 
    def wrapTheFunction():
        print(&quot;I am doing some boring work before executing a_func()&quot;)
 
        a_func()
 
        print(&quot;I am doing some boring work after executing a_func()&quot;)
 
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    &quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;
    print(&quot;I am the function which needs some decoration to &quot;
          &quot;remove my foul smell&quot;)
          
a_function_requiring_decoration()
#outputs: I am doing some boring work before executing a_func()
#         I am the function which needs some decoration to remove my foul smell
#         I am doing some boring work after executing a_func()
</code></pre>
<h1 id="pytorch相关"><a href="#pytorch相关" class="headerlink" title="pytorch相关"></a>pytorch相关</h1><h2 id="模型状态"><a href="#模型状态" class="headerlink" title="模型状态"></a>模型状态</h2><pre><code>model_state=model.state_dict()
</code></pre>
<h3 id="加载预训练的模型"><a href="#加载预训练的模型" class="headerlink" title="加载预训练的模型"></a>加载预训练的模型</h3><pre><code># Imagenet pretrain model
import torchvision.models as tm  # noqa: F401,F403
assert cfg[&#39;NUM_LAYERS&#39;] in [18, 34, 50, 101, 152]
x = eval(f&quot;tm.resnet&#123;cfg[&#39;NUM_LAYERS&#39;]&#125;(pretrained=True)&quot;)

# self.preact是自己的resnet
self.preact = ResNet(f&quot;resnet&#123;cfg[&#39;NUM_LAYERS&#39;]&#125;&quot;)

model_state = self.preact.state_dict()
state = &#123;k: v for k, v in x.state_dict().items() if k in self.preact.state_dict() and v.size() == self.preact.state_dict()[k].size()&#125;
model_state.update(state)
self.preact.load_state_dict(model_state)
</code></pre>
<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul()"></a>torch.mul()</h3><p>逐元素乘法</p>
<pre><code>import torch

a = torch.tensor([1, 2, 3])
b = torch.tensor([4, 5, 6])

c = torch.mul(a, b)
print(c)  # tensor([ 4, 10, 18])
</code></pre>
<h3 id="torch-dot"><a href="#torch-dot" class="headerlink" title="torch.dot()"></a>torch.dot()</h3><p>点积</p>
<pre><code>import torch

u = torch.tensor([1, 2, 3])
v = torch.tensor([4, 5, 6])

d = torch.dot(u, v)
print(d)  # tensor(32)
</code></pre>
<h2 id="dataset相关"><a href="#dataset相关" class="headerlink" title="dataset相关"></a>dataset相关</h2><h3 id="Sampler"><a href="#Sampler" class="headerlink" title="Sampler"></a>Sampler</h3><p><code>Sampler</code> 类是一个用于定义数据集中样本的顺序或采样策略的抽象基类</p>
<p><code>Sampler</code> 对数据集中的样本进行采样，以控制每个 batch 中的样本数量和顺序。</p>
<h4 id="RandomSampler"><a href="#RandomSampler" class="headerlink" title="RandomSampler"></a>RandomSampler</h4><h5 id="set-epoch"><a href="#set-epoch" class="headerlink" title="set_epoch"></a>set_epoch</h5><p>在每个 epoch 开始时，我们可以使用 <code>set_epoch</code> 方法来设置采样器的当前 epoch 值，以确保每个 epoch 中的样本顺序和数量都是不同的。</p>
<p>列如：</p>
<pre><code>from torch.utils.data import RandomSampler

# 创建一个 RandomSampler 采样器
sampler = RandomSampler(dataset)

# 训练神经网络
for i in range(num_epochs):
    # 设置采样器的当前 epoch 值
    sampler.set_epoch(i)
    
    # 创建 DataLoader，并使用 RandomSampler 采样器
    dataloader = DataLoader(dataset, batch_size=batch_size, sampler=sampler)
    
    # 在数据集上迭代
    for batch in dataloader:
        # 处理 batch 数据
        ...
</code></pre>
<p>在这个示例中，我们在训练神经网络的每个 epoch 开始时，使用 <code>set_epoch</code> 方法将采样器的当前 epoch 值设置为当前 epoch 的索引 <code>i</code>。然后，我们创建一个 DataLoader 对象，并将 <code>RandomSampler</code> 采样器应用于该数据集。在数据集上迭代时，<code>RandomSampler</code> 采样器将根据当前 epoch 值对数据集中的样本进行随机采样，以确保每个 batch 中的样本顺序和数量都是不同的。</p>
<h2 id="优化器相关"><a href="#优化器相关" class="headerlink" title="优化器相关"></a>优化器相关</h2><p><code>Optimizer</code> 是一个用于优化神经网络模型参数的类。</p>
<h3 id="param-groups"><a href="#param-groups" class="headerlink" title="param_groups"></a>param_groups</h3><p><code>param_groups</code> 是 <code>Optimizer</code> 类的一个属性，它返回一个包含优化器参数组的列表。每个参数组都是一个字典，</p>
<p><code>optimizer.param_groups[0]</code>：长度为7的字典，包括[‘<strong>params</strong>’, ‘<strong>lr</strong>’, ‘<strong>betas</strong>’, ‘<strong>eps</strong>’, ‘<strong>weight_decay</strong>’, ‘<strong>amsgrad</strong>’, ‘<strong>maximize</strong>’]这7个参数；</p>
<p>例如</p>
<pre><code>&gt;&gt;&gt; optimizer.param_groups[0].keys()
&gt;&gt;&gt; dict_keys([&#39;params&#39;, &#39;lr&#39;, &#39;betas&#39;, &#39;eps&#39;, &#39;weight_decay&#39;, &#39;amsgrad&#39;, &#39;maximize&#39;])
</code></pre>
<p><code>params</code> 是一个list[…]，里面存放参数</p>
<pre><code>&gt;&gt;&gt; len(optimizer.param_groups[0][&#39;params&#39;])
&gt;&gt;&gt; 48
&gt;&gt;&gt; optimizer.param_groups[0][&#39;params&#39;][0]
&gt;&gt;&gt; 
Parameter containing:
tensor([[ 0.0212, -0.1151,  0.0499,  ..., -0.0807, -0.0572,  0.1166],
        [-0.0356, -0.0397, -0.0980,  ...,  0.0690, -0.1066, -0.0583],
        [ 0.0238,  0.0316, -0.0636,  ...,  0.0754, -0.0891,  0.0258],
        ...,
        [ 0.0603, -0.0173,  0.0627,  ...,  0.0152, -0.0215, -0.0730],
        [-0.1183, -0.0636,  0.0381,  ...,  0.0745, -0.0427, -0.0713],
</code></pre>
<p><code>lr</code> 是学习率</p>
<pre><code>&gt;&gt;&gt; optimizer.param_groups[0][&#39;lr&#39;]
&gt;&gt;&gt; 0.0005
</code></pre>
<p><a href="https://blog.csdn.net/xxmy7/article/details/125967239">https://blog.csdn.net/xxmy7/article/details/125967239</a> 看这个链接</p>
<h2 id="梯度相关"><a href="#梯度相关" class="headerlink" title="梯度相关"></a>梯度相关</h2><h3 id="梯度裁剪代码"><a href="#梯度裁剪代码" class="headerlink" title="梯度裁剪代码"></a>梯度裁剪代码</h3><pre><code>def clip_gradient(optimizer, max_norm, norm_type):
    &quot;&quot;&quot;
    Clips gradients computed during backpropagation to avoid explosion of gradients.

    :param optimizer: optimizer with the gradients to be clipped
    :param grad_clip: clip value
    &quot;&quot;&quot;
    for group in optimizer.param_groups:
        for param in group[&quot;params&quot;]:
            clip_grad.clip_grad_norm_(param, max_norm, norm_type)
</code></pre>
<pre><code># 在RLE中设置的为
grad_clip = &#123;&#39;MAX_NORM&#39;: 35, &#39;NORM_TYPE&#39;: 2&#125;

optimizer.zero_grad()
loss.backward()
if grad_clip:
    clip_gradient(optimizer, grad_clip.MAX_NORM, grad_clip.NORM_TYPE)
    
optimizer.step()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>DAS</title>
    <url>/2023/07/23/DAS/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8c31c87647eeb5a6521613aa2ac2b0286caf1e10b1f91f6ec33feb07017d4b7f">7feab2e74e7ac8c26f5b44aac0c37567a8bb91f75c0616fb26c89457b269f27738d7080f82ed5c2859d32e78a013f589d201194c5f636a61dcff2e6d1deb9bd2b28e8af387e324797c7edcc76dc5b8ca9bc90ed0409c28ba395a33a855ceda3bdbb013fa8392c6d4b97f3c54f7ad34217944932b294460930b64b2eb8efa38fdc0b6e26453d43153f05b0d277ae48c6b9aa3aba55745b77f9a60ef1d55958b8cf8d19f2aa88fd59c1a7c2b31b2aff0d5c373c4e385c4f7bb56938973e4e4a92f142b59acddae948de4be209445bdac6f60a3cd45a4d89d9c1b3b26917dd281a9cd1633c47dc26282558e9e2df869b5f5e21a27fb6b732939fe0803feee2aeae27327cc6e029d99c532d01b4e09d2a78a7d64694eadd59ca1f982c65f520709221634b77a9e0b34283b38df344b8427620d4c7562e85d7663ba80edb9567ab219a7864ab230eafe24357e96f28cc5572dfdaa111f57113285f0d3104193ec28c06e75807b9d3067a79bb52c995994d110de61abcec2632a46f8ed50a836a75caea5ebd080ab6e8cfb22d3a1eca0829a5ee9900dc379ec8e94d5d4e05177bed6291944213949794e1cf0732f1ba010248041394f820a4b867369d88d8442f4344c0367aedad73005b421a02dac07d0b67bf6ae3174c2bb8e8307ebab50ad42d8e6cb7478442fd268b739e944f58b051a12694ef527208416ea60cbd865d3e8b340c013802aa6065c0b43f7eedc160ad84f9afaaeb9d558dbb502a09102e2192e68a05dfca00021a3350413e60fdab1622095ea5ba95b97f2a8deffddae3b4f7d41672803775cfe6785f88e047f9fb5344f6157816071ad2068c543c2d00f6c291b673619d31b3b167a0040915246e3b759eab36dd1e9f4e92758b60857e745c6234585e07bd6d5431490bae1db4d8dbbae90264d89997d5488ad59ca11cdea56fc5372ec452365b0b9f423fa56152a8b26e3f59c38917fee2b6333ebd1acdaf4935cd5797e93fb010b9b8cf2cb6874094102cf767563427fdefa2c833ed3a3398ac39077a2ee9c9b134b3431ff1bec2094ff9ee197f05aa7537fac1f3353eb8c9f9246243070b968e6bee6599b563cd1dfae0bd84d78b34b650d36bfeb1839ef9c26762f210fa8fa9d83d803017f274298d7602411fd9e7390fae7080466aed0e95ede5311fd3842cabd7db90ec46c2a9d3d4e858a46cb2bd1599ef0720778591a355ea9b17c92faa8b7bff32166d4ec39710a1c7dc7f85b0f3a0f634c761acac89d19e3e7643d97d8041bc6fde44c925dceb4bedbb353b3a0e708cac094b657d26dbfac43df9fcb813b8682d840989a64231947f9bd124a10d92a5c95440f4e4e38173f04e23d506832697abd6c5bd8164808e6b716b0a0c6234b7bf4d38862ad268ad4cf482666d51cdcce1a5c4656ae730388f103d96f7b356c2ef24628f8491e9c0a55c7d3b659b9eccc8ef163f402c6daf68fb23a1b8cf685f510d9b2aa2a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>pose</tag>
      </tags>
  </entry>
  <entry>
    <title>MotionGPT</title>
    <url>/2023/07/26/MotionGPT/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="motion-tasks"><a href="#motion-tasks" class="headerlink" title="motion tasks"></a>motion tasks</h2><h3 id="text-driven-motion-generation"><a href="#text-driven-motion-generation" class="headerlink" title="text-driven motion generation"></a>text-driven motion generation</h3><h3 id="motion-captioning运动描述"><a href="#motion-captioning运动描述" class="headerlink" title="motion captioning运动描述"></a>motion captioning运动描述</h3><h3 id="motion-prediction"><a href="#motion-prediction" class="headerlink" title="motion prediction"></a>motion prediction</h3><h3 id="motion-in-between"><a href="#motion-in-between" class="headerlink" title="motion in-between"></a>motion in-between</h3>]]></content>
      <tags>
        <tag>pose</tag>
      </tags>
  </entry>
</search>
